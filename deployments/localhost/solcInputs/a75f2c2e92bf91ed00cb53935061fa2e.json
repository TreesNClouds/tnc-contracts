{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@rari-capital/solmate/src/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                             EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    bytes32 public constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            bytes32 digest = keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n                )\n            );\n\n            address recoveredAddress = ecrecover(digest, v, r, s);\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "contracts/allocators/interfaces/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\npragma abicoder v2;\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouter {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n}\n"
    },
    "contracts/allocators/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\nimport \"../../interfaces/IERC20.sol\";\n\ninterface IWETH is IERC20 {\n    function deposit() external payable;\n\n    function withdraw(uint256) external;\n}\n"
    },
    "contracts/allocators/interfaces/LiquityInterfaces.sol": {
      "content": "//https://etherscan.io/address/0x66017D22b0f8556afDd19FC67041899Eb65a21bb\n/*\n * The Stability Pool holds LUSD tokens deposited by Stability Pool depositors.\n *\n * When a trove is liquidated, then depending on system conditions, some of its LUSD debt gets offset with\n * LUSD in the Stability Pool:  that is, the offset debt evaporates, and an equal amount of LUSD tokens in the Stability Pool is burned.\n *\n * Thus, a liquidation causes each depositor to receive a LUSD loss, in proportion to their deposit as a share of total deposits.\n * They also receive an ETH gain, as the ETH collateral of the liquidated trove is distributed among Stability depositors,\n * in the same proportion.\n *\n * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%\n * of the total LUSD in the Stability Pool, depletes 40% of each deposit.\n *\n * A deposit that has experienced a series of liquidations is termed a \"compounded deposit\": each liquidation depletes the deposit,\n * multiplying it by some factor in range ]0,1[\n *\n * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / ETH gain derivations:\n * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf\n *\n * --- LQTY ISSUANCE TO STABILITY POOL DEPOSITORS ---\n *\n * An LQTY issuance event occurs at every deposit operation, and every liquidation.\n *\n * Each deposit is tagged with the address of the front end through which it was made.\n *\n * All deposits earn a share of the issued LQTY in proportion to the deposit as a share of total deposits. The LQTY earned\n * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.\n *\n * Please see the system Readme for an overview:\n * https://github.com/liquity/dev/blob/main/README.md#lqty-issuance-to-stability-providers\n */\ninterface IStabilityPool {\n    // --- Functions ---\n    /*\n     * Initial checks:\n     * - Frontend is registered or zero address\n     * - Sender is not a registered frontend\n     * - _amount is not zero\n     * ---\n     * - Triggers a LQTY issuance, based on time passed since the last issuance. The LQTY issuance is shared between *all* depositors and front ends\n     * - Tags the deposit with the provided front end tag param, if it's a new deposit\n     * - Sends depositor's accumulated gains (LQTY, ETH) to depositor\n     * - Sends the tagged front end's accumulated LQTY gains to the tagged front end\n     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.\n     */\n    function provideToSP(uint256 _amount, address _frontEndTag) external;\n\n    /*\n     * Initial checks:\n     * - _amount is zero or there are no under collateralized troves left in the system\n     * - User has a non zero deposit\n     * ---\n     * - Triggers a LQTY issuance, based on time passed since the last issuance. The LQTY issuance is shared between *all* depositors and front ends\n     * - Removes the deposit's front end tag if it is a full withdrawal\n     * - Sends all depositor's accumulated gains (LQTY, ETH) to depositor\n     * - Sends the tagged front end's accumulated LQTY gains to the tagged front end\n     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.\n     *\n     * If _amount > userDeposit, the user withdraws all of their compounded deposit.\n     */\n    function withdrawFromSP(uint256 _amount) external;\n\n    /*\n     * Initial checks:\n     * - User has a non zero deposit\n     * - User has an open trove\n     * - User has some ETH gain\n     * ---\n     * - Triggers a LQTY issuance, based on time passed since the last issuance. The LQTY issuance is shared between *all* depositors and front ends\n     * - Sends all depositor's LQTY gain to  depositor\n     * - Sends all tagged front end's LQTY gain to the tagged front end\n     * - Transfers the depositor's entire ETH gain from the Stability Pool to the caller's trove\n     * - Leaves their compounded deposit in the Stability Pool\n     * - Updates snapshots for deposit and tagged front end stake\n     */\n    function withdrawETHGainToTrove(address _upperHint, address _lowerHint) external;\n\n    /*\n     * Initial checks:\n     * - Frontend (sender) not already registered\n     * - User (sender) has no deposit\n     * - _kickbackRate is in the range [0, 100%]\n     * ---\n     * Front end makes a one-time selection of kickback rate upon registering\n     */\n    function registerFrontEnd(uint256 _kickbackRate) external;\n\n    /*\n     * Initial checks:\n     * - Caller is TroveManager\n     * ---\n     * Cancels out the specified debt against the LUSD contained in the Stability Pool (as far as possible)\n     * and transfers the Trove's ETH collateral from ActivePool to StabilityPool.\n     * Only called by liquidation functions in the TroveManager.\n     */\n    function offset(uint256 _debt, uint256 _coll) external;\n\n    /*\n     * Returns the total amount of ETH held by the pool, accounted in an internal variable instead of `balance`,\n     * to exclude edge cases like ETH received from a self-destruct.\n     */\n    function getETH() external view returns (uint256);\n\n    /*\n     * Returns LUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\n     */\n    function getTotalLUSDDeposits() external view returns (uint256);\n\n    /*\n     * Calculates the ETH gain earned by the deposit since its last snapshots were taken.\n     */\n    function getDepositorETHGain(address _depositor) external view returns (uint256);\n\n    /*\n     * Calculate the LQTY gain earned by a deposit since its last snapshots were taken.\n     * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.\n     * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through\n     * which they made their deposit.\n     */\n    function getDepositorLQTYGain(address _depositor) external view returns (uint256);\n\n    /*\n     * Return the LQTY gain earned by the front end.\n     */\n    function getFrontEndLQTYGain(address _frontEnd) external view returns (uint256);\n\n    /*\n     * Return the user's compounded deposit.\n     */\n    function getCompoundedLUSDDeposit(address _depositor) external view returns (uint256);\n\n    /*\n     * Return the front end's compounded stake.\n     *\n     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.\n     */\n    function getCompoundedFrontEndStake(address _frontEnd) external view returns (uint256);\n}\n\n//\ninterface ILQTYStaking {\n    /*\n        sends _LQTYAmount from the caller to the staking contract, and increases their stake.\n        If the caller already has a non-zero stake, it pays out their accumulated ETH and LUSD gains from staking.\n    */\n    function stake(uint256 _LQTYamount) external;\n\n    /**\n        reduces the callerâ€™s stake by _LQTYamount, up to a maximum of their entire stake. \n        It pays out their accumulated ETH and LUSD gains from staking.\n    */\n    function unstake(uint256 _LQTYamount) external;\n\n    function getPendingETHGain(address _user) external view returns (uint256);\n\n    function getPendingLUSDGain(address _user) external view returns (uint256);\n}\n"
    },
    "contracts/allocators/LUSDAllocator.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"../libraries/SafeERC20.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IERC20Metadata.sol\";\nimport \"../interfaces/ITreasury.sol\";\nimport \"./interfaces/ISwapRouter.sol\";\nimport \"./interfaces/IWETH.sol\";\nimport \"./interfaces/LiquityInterfaces.sol\";\nimport \"../types/OlympusAccessControlled.sol\";\n\n/**\n *  Contract deploys reserves from treasury into the liquity stabilty pool, and those rewards\n *  are then paid out to the staking contract.  See harvest() function for more details.\n */\n\ncontract LUSDAllocator is OlympusAccessControlled {\n    /* ======== DEPENDENCIES ======== */\n\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IWETH;\n\n    event Deposit(address indexed dst, uint256 amount);\n\n    /* ======== STATE VARIABLES ======== */\n    IStabilityPool immutable lusdStabilityPool;\n    ILQTYStaking immutable lqtyStaking;\n    IWETH immutable weth; // WETH address (0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)\n    ISwapRouter immutable swapRouter;\n    ITreasury public treasury; // Olympus Treasury\n\n    uint256 public constant FEE_PRECISION = 1e6;\n    uint256 public constant POOL_FEE_MAX = 10000;\n    /**\n     * @notice The target percent of eth to swap to LUSD at uniswap.  divide by 1e6 to get actual value.\n     * Examples:\n     * 500000 => 500000 / 1e6 = 0.50 = 50%\n     * 330000 => 330000 / 1e6 = 0.33 = 33%\n     */\n    uint256 public ethToLUSDRatio = 330000; // 33% of ETH to LUSD\n    /**\n     * @notice poolFee parameter for uniswap swaprouter, divide by 1e6 to get the actual value.  See https://docs.uniswap.org/protocol/guides/swaps/multihop-swaps#calling-the-function-1\n     * Maximum allowed value is 10000 (1%)\n     * Examples:\n     * poolFee =  3000 =>  3000 / 1e6 = 0.003 = 0.3%\n     * poolFee = 10000 => 10000 / 1e6 =  0.01 = 1.0%\n     */\n    uint256 public poolFee = 3000; // Init the uniswap pool fee to 0.3%\n\n    address public hopTokenAddress; //Initially DAI, could potentially be USDC\n\n    // TODO(zx): I don't think we care about front-end because we're our own frontend.\n    address public frontEndAddress; // frontEndAddress for potential liquity rewards\n    address public lusdTokenAddress; // LUSD Address (0x5f98805A4E8be255a32880FDeC7F6728C6568bA0)\n    address public lqtyTokenAddress; // LQTY Address (0x6DEA81C8171D0bA574754EF6F8b412F2Ed88c54D)  from https://github.com/liquity/dev/blob/a12f8b737d765bfee6e1bfcf8bf7ef155c814e1e/packages/contracts/mainnetDeployment/realDeploymentOutput/output14.txt#L61\n\n    uint256 public totalValueDeployed; // total RFV deployed into lending pool\n    uint256 public totalAmountDeployed; // Total amount of tokens deployed\n\n    /* ======== CONSTRUCTOR ======== */\n\n    constructor(\n        address _authority,\n        address _treasury,\n        address _lusdTokenAddress,\n        address _lqtyTokenAddress,\n        address _stabilityPool,\n        address _lqtyStaking,\n        address _frontEndAddress,\n        address _wethAddress,\n        address _hopTokenAddress,\n        address _uniswapV3Router\n    ) OlympusAccessControlled(IOlympusAuthority(_authority)) {\n        treasury = ITreasury(_treasury);\n        lusdTokenAddress = _lusdTokenAddress;\n        lqtyTokenAddress = _lqtyTokenAddress;\n        lusdStabilityPool = IStabilityPool(_stabilityPool);\n        lqtyStaking = ILQTYStaking(_lqtyStaking);\n        frontEndAddress = _frontEndAddress; // address can be 0\n        weth = IWETH(_wethAddress);\n        hopTokenAddress = _hopTokenAddress; // address can be 0\n        swapRouter = ISwapRouter(_uniswapV3Router);\n\n        // infinite approve to save gas\n        weth.safeApprove(address(treasury), type(uint256).max);\n        weth.safeApprove(address(swapRouter), type(uint256).max);\n        IERC20(lusdTokenAddress).safeApprove(address(lusdStabilityPool), type(uint256).max);\n        IERC20(lusdTokenAddress).safeApprove(address(treasury), type(uint256).max);\n        IERC20(lqtyTokenAddress).safeApprove(address(treasury), type(uint256).max);\n    }\n\n    /**\n        StabilityPool::withdrawFromSP() and LQTYStaking::stake() will send ETH here, so capture and emit the event\n     */\n    receive() external payable {\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    /* ======== CONFIGURE FUNCTIONS for Guardian only ======== */\n    function setEthToLUSDRatio(uint256 _ethToLUSDRatio) external onlyGuardian {\n        require(_ethToLUSDRatio <= FEE_PRECISION, \"Value must be between 0 and 1e6\");\n        ethToLUSDRatio = _ethToLUSDRatio;\n    }\n\n    function setPoolFee(uint256 _poolFee) external onlyGuardian {\n        require(_poolFee <= POOL_FEE_MAX, \"Value must be between 0 and 10000\");\n        poolFee = _poolFee;\n    }\n\n    function setHopTokenAddress(address _hopTokenAddress) external onlyGuardian {\n        hopTokenAddress = _hopTokenAddress;\n    }\n\n    /**\n     *  @notice setsFrontEndAddress for Stability pool rewards\n     *  @param _frontEndAddress address\n     */\n    function setFrontEndAddress(address _frontEndAddress) external onlyGuardian {\n        frontEndAddress = _frontEndAddress;\n    }\n\n    function updateTreasury() public onlyGuardian {\n        require(authority.vault() != address(0), \"Zero address: Vault\");\n        require(address(authority.vault()) != address(treasury), \"No change\");\n        treasury = ITreasury(authority.vault());\n    }\n\n    /* ======== OPEN FUNCTIONS ======== */\n\n    /**\n     *  @notice claims LQTY & ETH Rewards.   minETHLUSDRate minimum rate of when swapping ETH->LUSD.  e.g. 3500 means we swap at a rate of 1 ETH for a minimum 3500 LUSD\n     \n        1.  Harvest from LUSD StabilityPool to get ETH+LQTY rewards\n        2.  Stake LQTY rewards from #1.  This txn will also give out any outstanding ETH+LUSD rewards from prior staking\n        3.  If we have eth, convert to weth, then swap a percentage of it to LUSD.  If swap successul then send all remaining WETH to treasury\n        4.  Deposit LUSD from #2 and potentially #3 into StabilityPool\n     */\n    function harvest(uint256 minETHLUSDRate) public onlyGuardian returns (bool) {\n        uint256 stabilityPoolEthRewards = getETHRewards();\n        uint256 stabilityPoolLqtyRewards = getLQTYRewards();\n\n        if (stabilityPoolEthRewards == 0 && stabilityPoolLqtyRewards == 0) {\n            return false;\n        }\n        // 1.  Harvest from LUSD StabilityPool to get ETH+LQTY rewards\n        lusdStabilityPool.withdrawFromSP(0); //Passing 0 b/c we don't want to withdraw from the pool but harvest - see https://discord.com/channels/700620821198143498/818895484956835912/908031137010581594\n\n        // 2.  Stake LQTY rewards from #1.  This txn will also give out any outstanding ETH+LUSD rewards from prior staking\n        uint256 balanceLqty = IERC20(lqtyTokenAddress).balanceOf(address(this)); // LQTY balance received from stability pool\n        if (balanceLqty > 0) {\n            //Stake\n            lqtyStaking.stake(balanceLqty); //Stake LQTY, also receives any prior ETH+LUSD rewards from prior staking\n        }\n\n        // 3.  If we have eth, convert to weth, then swap a percentage of it to LUSD.  If swap successul then send all remaining WETH to treasury\n        uint256 ethBalance = address(this).balance; // Use total balance in case we have leftover from a prior failed attempt\n        bool swappedLUSDSuccessfully;\n        if (ethBalance > 0) {\n            // Wrap ETH to WETH\n            weth.deposit{value: ethBalance}();\n\n            uint256 wethBalance = weth.balanceOf(address(this)); //Base off of WETH balance in case we have leftover from a prior failed attempt\n            if (ethToLUSDRatio > 0) {\n                uint256 amountWethToSwap = (wethBalance * ethToLUSDRatio) / FEE_PRECISION;\n\n                uint256 amountLUSDMin = amountWethToSwap * minETHLUSDRate; //WETH and LUSD is 18 decimals\n\n                // From https://docs.uniswap.org/protocol/guides/swaps/multihop-swaps#calling-the-function-1\n                // Multiple pool swaps are encoded through bytes called a `path`. A path is a sequence of token addresses and poolFees that define the pools used in the swaps.\n                // The format for pool encoding is (tokenIn, fee, tokenOut/tokenIn, fee, tokenOut) where tokenIn/tokenOut parameter is the shared token across the pools.\n                // Since we are swapping WETH to DAI and then DAI to LUSD the path encoding is (WETH, 0.3%, DAI, 0.3%, LUSD).\n                ISwapRouter.ExactInputParams memory params = ISwapRouter.ExactInputParams({\n                    path: abi.encodePacked(address(weth), poolFee, hopTokenAddress, poolFee, lusdTokenAddress),\n                    recipient: address(this), //Send LUSD here\n                    deadline: block.timestamp + 25, //25 blocks, at 12 seconds per block is 5 minutes\n                    amountIn: amountWethToSwap,\n                    amountOutMinimum: amountLUSDMin\n                });\n\n                // Executes the swap\n                if (swapRouter.exactInput(params) > 0) {\n                    swappedLUSDSuccessfully = true;\n                }\n            }\n        }\n        if (ethToLUSDRatio == 0 || swappedLUSDSuccessfully) {\n            // If swap was successful (or if percent to swap is 0), send the remaining WETH to the treasury.  Crucial check otherwise we'd send all our WETH to the treasury and not respect our desired percentage\n\n            // Get updated balance, send to treasury\n            uint256 wethBalance = weth.balanceOf(address(this));\n            if (wethBalance > 0) {\n                // transfer WETH to treasury\n                weth.safeTransfer(address(treasury), wethBalance);\n            }\n        }\n\n        // 4.  Deposit LUSD from #2 and potentially #3 into StabilityPool\n        uint256 lusdBalance = IERC20(lusdTokenAddress).balanceOf(address(this));\n        if (lusdBalance > 0) {\n            _depositLUSD(lusdBalance);\n        }\n\n        return true;\n    }\n\n    /* ======== POLICY FUNCTIONS ======== */\n\n    /**\n     *  @notice withdraws asset from treasury, deposits asset into stability pool\n     *  @param amount uint\n     */\n    function deposit(uint256 amount) external onlyGuardian {\n        treasury.manage(lusdTokenAddress, amount); // retrieve amount of asset from treasury\n\n        _depositLUSD(amount);\n    }\n\n    /**\n     *  @notice withdraws from stability pool, and deposits asset into treasury\n     *  @param token address\n     *  @param amount uint\n     */\n    function withdraw(address token, uint256 amount) external onlyGuardian {\n        require(\n            token == lusdTokenAddress || token == lqtyTokenAddress,\n            \"token address does not match LUSD nor LQTY token\"\n        );\n\n        if (token == lusdTokenAddress) {\n            lusdStabilityPool.withdrawFromSP(amount); // withdraw from SP\n\n            uint256 balance = IERC20(token).balanceOf(address(this)); // balance of asset received from stability pool\n            uint256 value = _tokenValue(token, balance); // treasury RFV calculator\n\n            _accountingFor(balance, value, false); // account for withdrawal\n\n            treasury.deposit(balance, token, value); // deposit using value as profit so no OHM is minted\n        } else {\n            lqtyStaking.unstake(amount);\n\n            uint256 balance = IERC20(token).balanceOf(address(this)); // balance of asset received from stability pool\n            IERC20(token).safeTransfer(address(treasury), balance);\n        }\n    }\n\n    /* ======== INTERNAL FUNCTIONS ======== */\n\n    function _depositLUSD(uint256 amount) internal {\n        lusdStabilityPool.provideToSP(amount, frontEndAddress); //s either a front-end address OR 0x0\n\n        uint256 value = _tokenValue(lusdTokenAddress, amount); // treasury RFV calculator\n        _accountingFor(amount, value, true); // account for deposit\n    }\n\n    /**\n     *  @notice accounting of deposits/withdrawals of assets\n     *  @param amount uint\n     *  @param value uint\n     *  @param add bool\n     */\n    function _accountingFor(\n        uint256 amount,\n        uint256 value,\n        bool add\n    ) internal {\n        if (add) {\n            totalAmountDeployed = totalAmountDeployed + amount;\n            totalValueDeployed = totalValueDeployed + value; // track total value allocated into pools\n        } else {\n            // track total value allocated into pools\n            if (amount < totalAmountDeployed) {\n                totalAmountDeployed = totalAmountDeployed - amount;\n            } else {\n                totalAmountDeployed = 0;\n            }\n\n            if (value < totalValueDeployed) {\n                totalValueDeployed = totalValueDeployed - value;\n            } else {\n                totalValueDeployed = 0;\n            }\n        }\n    }\n\n    /**\n    Helper method copying OlympusTreasury::_tokenValue(), whose name was 'valueOf()' in v1 \n    Implemented here so we don't have to upgrade contract later\n     */\n    function _tokenValue(address _token, uint256 _amount) internal view returns (uint256 value_) {\n        value_ = (_amount * (10**9)) / (10**IERC20Metadata(_token).decimals());\n        return value_;\n    }\n\n    /* ======== VIEW FUNCTIONS ======== */\n\n    /**\n     *  @notice get ETH rewards from SP\n     *  @return uint\n     */\n    function getETHRewards() public view returns (uint256) {\n        return lusdStabilityPool.getDepositorETHGain(address(this));\n    }\n\n    /**\n     *  @notice get LQTY rewards from SP\n     *  @return uint\n     */\n    function getLQTYRewards() public view returns (uint256) {\n        return lusdStabilityPool.getDepositorLQTYGain(address(this));\n    }\n}\n"
    },
    "contracts/allocators/MetaGovernanceAllocator.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"../libraries/SafeERC20.sol\";\n\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/ITreasury.sol\";\n\nimport \"../types/OlympusAccessControlled.sol\";\n\ninterface IStaking {\n    function stake(uint256 _amount, address _recipient) external returns (bool);\n\n    function unstake(uint256 _amount, bool _trigger) external;\n\n    function claim(address _recipient) external;\n}\n\n/// @title   Meta Governance Allocator\n/// @author  Olympus\n/// @notice  Manages BTRFLY or LOBI from treasury to stake back to treasury\ncontract MetaGovernanceAllocator is OlympusAccessControlled {\n    using SafeERC20 for IERC20;\n\n    /// @notice Olympus Treasury\n    ITreasury internal treasury = ITreasury(0x9A315BdF513367C0377FB36545857d12e85813Ef);\n    /// @notice BTRFLY token address\n    address internal immutable BTRFLY = 0xC0d4Ceb216B3BA9C3701B291766fDCbA977ceC3A;\n    /// @notice Staked BTRFLY token address\n    address internal immutable xBTRFLY = 0xCC94Faf235cC5D3Bf4bEd3a30db5984306c86aBC;\n    /// @notice Redacted staking contract\n    address internal immutable redactedStaking = 0xBdE4Dfb0dbb0Dd8833eFb6C5BD0Ce048C852C487;\n    /// @notice LOBI token address\n    address internal immutable LOBI = 0xDEc41Db0c33F3F6f3cb615449C311ba22D418A8d;\n    /// @notice Staked LOBI token address\n    address internal immutable sLOBI = 0x8Ab17e2cd4F894F8641A31f99F673a5762F53c8e;\n    /// @notice LOBI Staking contract\n    address internal immutable lobiStaking = 0x3818eff63418e0a0BA3980ABA5fF388b029b6d90;\n\n    /// CONSTRUCTOR ///\n\n    ///  @param _authority  Address of the Olympus Authority contract\n    constructor(IOlympusAuthority _authority) OlympusAccessControlled(_authority) {}\n\n    /// POLICY FUNCTIONS ///\n\n    /// @notice  If vault has been updated through authority contract update treasury address\n    function updateTreasury() external onlyGuardian {\n        require(authority.vault() != address(0), \"Zero address: Vault\");\n        require(address(authority.vault()) != address(treasury), \"No change\");\n        treasury = ITreasury(authority.vault());\n    }\n\n    /// @notice           Stakes either BTRFLY or LOBI from treasury\n    /// @param _redacted  Bool if staking to redacted or lobi\n    /// @param _amount    Amount of token that will be withdrawn from treasury and staked\n    function stake(bool _redacted, uint256 _amount) external onlyGuardian {\n        (address staking, address token, ) = _redactedOrLobi(_redacted);\n\n        // retrieve amount of token from treasury\n        treasury.manage(token, _amount);\n\n        // approve token to be spent by staking\n        IERC20(token).approve(staking, _amount);\n\n        // stake token to treasury\n        IStaking(staking).stake(_amount, address(treasury));\n\n        // claim stake for treasury\n        IStaking(staking).claim(address(treasury));\n    }\n\n    /// @notice           Unstakes either BTRFLY or LOBI from treasury\n    /// @param _redacted  Bool if unstakiung to redacted or lobi\n    /// @param _amount    Amount of token that will be withdrawn from treasury and unstaked\n    function unstake(bool _redacted, uint256 _amount) external onlyGuardian {\n        (address staking, address token, address stakedToken) = _redactedOrLobi(_redacted);\n\n        // retrieve amount of staked token from treasury\n        treasury.manage(stakedToken, _amount);\n\n        // approve staked token to be spent by staking contract\n        IERC20(stakedToken).approve(staking, _amount);\n\n        // unstake token\n        IStaking(staking).unstake(_amount, false);\n\n        // send token back to treasury\n        IERC20(token).safeTransfer(address(treasury), _amount);\n    }\n\n    /// INTERNAL VIEW FUNCTIONS ///\n\n    /// @notice              Returns addresses depending on wanting to interact with redacted or lobi\n    /// @param _redacted     Bool if address for redacted or lobi\n    /// @return staking      Address of staking contract\n    /// @return token        Address of native token\n    /// @return stakedToken  Address of staked token\n    function _redactedOrLobi(bool _redacted)\n        internal\n        view\n        returns (\n            address staking,\n            address token,\n            address stakedToken\n        )\n    {\n        if (_redacted) {\n            staking = redactedStaking;\n            token = BTRFLY;\n            stakedToken = xBTRFLY;\n        } else {\n            staking = lobiStaking;\n            token = LOBI;\n            stakedToken = sLOBI;\n        }\n    }\n}\n"
    },
    "contracts/BondDepository.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"./types/NoteKeeper.sol\";\n\nimport \"./libraries/SafeERC20.sol\";\n\nimport \"./interfaces/IERC20Metadata.sol\";\nimport \"./interfaces/IBondDepository.sol\";\n\n/// @title Olympus Bond Depository V2\n/// @author Zeus, Indigo\n/// Review by: JeffX\n\ncontract OlympusBondDepositoryV2 is IBondDepository, NoteKeeper {\n    /* ======== DEPENDENCIES ======== */\n\n    using SafeERC20 for IERC20;\n\n    /* ======== EVENTS ======== */\n\n    event CreateMarket(uint256 indexed id, address indexed baseToken, address indexed quoteToken, uint256 initialPrice);\n    event CloseMarket(uint256 indexed id);\n    event Bond(uint256 indexed id, uint256 amount, uint256 price);\n    event Tuned(uint256 indexed id, uint64 oldControlVariable, uint64 newControlVariable);\n\n    /* ======== STATE VARIABLES ======== */\n\n    // Storage\n    Market[] public markets; // persistent market data\n    Terms[] public terms; // deposit construction data\n    Metadata[] public metadata; // extraneous market data\n    mapping(uint256 => Adjustment) public adjustments; // control variable changes\n\n    // Queries\n    mapping(address => uint256[]) public marketsForQuote; // market IDs for quote token\n\n    /* ======== CONSTRUCTOR ======== */\n\n    constructor(\n        IOlympusAuthority _authority,\n        IERC20 _ohm,\n        IgOHM _gohm,\n        IStaking _staking,\n        ITreasury _treasury\n    ) NoteKeeper(_authority, _ohm, _gohm, _staking, _treasury) {\n        // save gas for users by bulk approving stake() transactions\n        _ohm.approve(address(_staking), 1e45);\n    }\n\n    /* ======== DEPOSIT ======== */\n\n    /**\n     * @notice             deposit quote tokens in exchange for a bond from a specified market\n     * @param _id          the ID of the market\n     * @param _amount      the amount of quote token to spend\n     * @param _maxPrice    the maximum price at which to buy\n     * @param _user        the recipient of the payout\n     * @param _referral    the front end operator address\n     * @return payout_     the amount of gOHM due\n     * @return expiry_     the timestamp at which payout is redeemable\n     * @return index_      the user index of the Note (used to redeem or query information)\n     */\n    function deposit(\n        uint256 _id,\n        uint256 _amount,\n        uint256 _maxPrice,\n        address _user,\n        address _referral\n    )\n        external\n        override\n        returns (\n            uint256 payout_,\n            uint256 expiry_,\n            uint256 index_\n        )\n    {\n        Market storage market = markets[_id];\n        Terms memory term = terms[_id];\n        uint48 currentTime = uint48(block.timestamp);\n\n        // Markets end at a defined timestamp\n        // |-------------------------------------| t\n        require(currentTime < term.conclusion, \"Depository: market concluded\");\n\n        // Debt and the control variable decay over time\n        _decay(_id, currentTime);\n\n        // Users input a maximum price, which protects them from price changes after\n        // entering the mempool. max price is a slippage mitigation measure\n        uint256 price = _marketPrice(_id);\n        require(price <= _maxPrice, \"Depository: more than max price\");\n\n        /**\n         * payout for the deposit = amount / price\n         *\n         * where\n         * payout = OHM out\n         * amount = quote tokens in\n         * price = quote tokens : ohm (i.e. 42069 DAI : OHM)\n         *\n         * 1e18 = OHM decimals (9) + price decimals (9)\n         */\n        payout_ = ((_amount * 1e18) / price) / (10**metadata[_id].quoteDecimals);\n\n        // markets have a max payout amount, capping size because deposits\n        // do not experience slippage. max payout is recalculated upon tuning\n        require(payout_ <= market.maxPayout, \"Depository: max size exceeded\");\n\n        /*\n         * each market is initialized with a capacity\n         *\n         * this is either the number of OHM that the market can sell\n         * (if capacity in quote is false),\n         *\n         * or the number of quote tokens that the market can buy\n         * (if capacity in quote is true)\n         */\n        market.capacity -= market.capacityInQuote ? _amount : payout_;\n\n        /**\n         * bonds mature with a cliff at a set timestamp\n         * prior to the expiry timestamp, no payout tokens are accessible to the user\n         * after the expiry timestamp, the entire payout can be redeemed\n         *\n         * there are two types of bonds: fixed-term and fixed-expiration\n         *\n         * fixed-term bonds mature in a set amount of time from deposit\n         * i.e. term = 1 week. when alice deposits on day 1, her bond\n         * expires on day 8. when bob deposits on day 2, his bond expires day 9.\n         *\n         * fixed-expiration bonds mature at a set timestamp\n         * i.e. expiration = day 10. when alice deposits on day 1, her term\n         * is 9 days. when bob deposits on day 2, his term is 8 days.\n         */\n        expiry_ = term.fixedTerm ? term.vesting + currentTime : term.vesting;\n\n        // markets keep track of how many quote tokens have been\n        // purchased, and how much OHM has been sold\n        market.purchased += _amount;\n        market.sold += uint64(payout_);\n\n        // incrementing total debt raises the price of the next bond\n        market.totalDebt += uint64(payout_);\n\n        emit Bond(_id, _amount, price);\n\n        /**\n         * user data is stored as Notes. these are isolated array entries\n         * storing the amount due, the time created, the time when payout\n         * is redeemable, the time when payout was redeemed, and the ID\n         * of the market deposited into\n         */\n        index_ = addNote(_user, payout_, uint48(expiry_), uint48(_id), _referral);\n\n        // transfer payment to treasury\n        market.quoteToken.safeTransferFrom(msg.sender, address(treasury), _amount);\n\n        // if max debt is breached, the market is closed\n        // this a circuit breaker\n        if (term.maxDebt < market.totalDebt) {\n            market.capacity = 0;\n            emit CloseMarket(_id);\n        } else {\n            // if market will continue, the control variable is tuned to hit targets on time\n            _tune(_id, currentTime);\n        }\n    }\n\n    /**\n     * @notice             decay debt, and adjust control variable if there is an active change\n     * @param _id          ID of market\n     * @param _time        uint48 timestamp (saves gas when passed in)\n     */\n    function _decay(uint256 _id, uint48 _time) internal {\n        // Debt decay\n\n        /*\n         * Debt is a time-decayed sum of tokens spent in a market\n         * Debt is added when deposits occur and removed over time\n         * |\n         * |    debt falls with\n         * |   / \\  inactivity       / \\\n         * | /     \\              /\\/    \\\n         * |         \\           /         \\\n         * |           \\      /\\/            \\\n         * |             \\  /  and rises       \\\n         * |                with deposits\n         * |\n         * |------------------------------------| t\n         */\n        markets[_id].totalDebt -= debtDecay(_id);\n        metadata[_id].lastDecay = _time;\n\n        // Control variable decay\n\n        // The bond control variable is continually tuned. When it is lowered (which\n        // lowers the market price), the change is carried out smoothly over time.\n        if (adjustments[_id].active) {\n            Adjustment storage adjustment = adjustments[_id];\n\n            (uint64 adjustBy, uint48 secondsSince, bool stillActive) = _controlDecay(_id);\n            terms[_id].controlVariable -= adjustBy;\n\n            if (stillActive) {\n                adjustment.change -= adjustBy;\n                adjustment.timeToAdjusted -= secondsSince;\n                adjustment.lastAdjustment = _time;\n            } else {\n                adjustment.active = false;\n            }\n        }\n    }\n\n    /**\n     * @notice             auto-adjust control variable to hit capacity/spend target\n     * @param _id          ID of market\n     * @param _time        uint48 timestamp (saves gas when passed in)\n     */\n    function _tune(uint256 _id, uint48 _time) internal {\n        Metadata memory meta = metadata[_id];\n\n        if (_time >= meta.lastTune + meta.tuneInterval) {\n            Market memory market = markets[_id];\n\n            // compute seconds remaining until market will conclude\n            uint256 timeRemaining = terms[_id].conclusion - _time;\n            uint256 price = _marketPrice(_id);\n\n            // standardize capacity into an base token amount\n            // ohm decimals (9) + price decimals (9)\n            uint256 capacity = market.capacityInQuote\n                ? ((market.capacity * 1e18) / price) / (10**meta.quoteDecimals)\n                : market.capacity;\n\n            /**\n             * calculate the correct payout to complete on time assuming each bond\n             * will be max size in the desired deposit interval for the remaining time\n             *\n             * i.e. market has 10 days remaining. deposit interval is 1 day. capacity\n             * is 10,000 OHM. max payout would be 1,000 OHM (10,000 * 1 / 10).\n             */\n            markets[_id].maxPayout = uint64((capacity * meta.depositInterval) / timeRemaining);\n\n            // calculate the ideal total debt to satisfy capacity in the remaining time\n            uint256 targetDebt = (capacity * meta.length) / timeRemaining;\n\n            // derive a new control variable from the target debt and current supply\n            uint64 newControlVariable = uint64((price * treasury.baseSupply()) / targetDebt);\n\n            emit Tuned(_id, terms[_id].controlVariable, newControlVariable);\n\n            if (newControlVariable >= terms[_id].controlVariable) {\n                terms[_id].controlVariable = newControlVariable;\n            } else {\n                // if decrease, control variable change will be carried out over the tune interval\n                // this is because price will be lowered\n                uint64 change = terms[_id].controlVariable - newControlVariable;\n                adjustments[_id] = Adjustment(change, _time, meta.tuneInterval, true);\n            }\n            metadata[_id].lastTune = _time;\n        }\n    }\n\n    /* ======== CREATE ======== */\n\n    /**\n     * @notice             creates a new market type\n     * @dev                current price should be in 9 decimals.\n     * @param _quoteToken  token used to deposit\n     * @param _market      [capacity (in OHM or quote), initial price / OHM (9 decimals), debt buffer (3 decimals)]\n     * @param _booleans    [capacity in quote, fixed term]\n     * @param _terms       [vesting length (if fixed term) or vested timestamp, conclusion timestamp]\n     * @param _intervals   [deposit interval (seconds), tune interval (seconds)]\n     * @return id_         ID of new bond market\n     */\n    function create(\n        IERC20 _quoteToken,\n        uint256[3] memory _market,\n        bool[2] memory _booleans,\n        uint256[2] memory _terms,\n        uint32[2] memory _intervals\n    ) external override onlyPolicy returns (uint256 id_) {\n        // the length of the program, in seconds\n        uint256 secondsToConclusion = _terms[1] - block.timestamp;\n\n        // the decimal count of the quote token\n        uint256 decimals = IERC20Metadata(address(_quoteToken)).decimals();\n\n        /*\n         * initial target debt is equal to capacity (this is the amount of debt\n         * that will decay over in the length of the program if price remains the same).\n         * it is converted into base token terms if passed in in quote token terms.\n         *\n         * 1e18 = ohm decimals (9) + initial price decimals (9)\n         */\n        uint64 targetDebt = uint64(_booleans[0] ? ((_market[0] * 1e18) / _market[1]) / 10**decimals : _market[0]);\n\n        /*\n         * max payout is the amount of capacity that should be utilized in a deposit\n         * interval. for example, if capacity is 1,000 OHM, there are 10 days to conclusion,\n         * and the preferred deposit interval is 1 day, max payout would be 100 OHM.\n         */\n        uint64 maxPayout = uint64((targetDebt * _intervals[0]) / secondsToConclusion);\n\n        /*\n         * max debt serves as a circuit breaker for the market. let's say the quote\n         * token is a stablecoin, and that stablecoin depegs. without max debt, the\n         * market would continue to buy until it runs out of capacity. this is\n         * configurable with a 3 decimal buffer (1000 = 1% above initial price).\n         * note that its likely advisable to keep this buffer wide.\n         * note that the buffer is above 100%. i.e. 10% buffer = initial debt * 1.1\n         */\n        uint256 maxDebt = targetDebt + ((targetDebt * _market[2]) / 1e5); // 1e5 = 100,000. 10,000 / 100,000 = 10%.\n\n        /*\n         * the control variable is set so that initial price equals the desired\n         * initial price. the control variable is the ultimate determinant of price,\n         * so we compute this last.\n         *\n         * price = control variable * debt ratio\n         * debt ratio = total debt / supply\n         * therefore, control variable = price / debt ratio\n         */\n        uint256 controlVariable = (_market[1] * treasury.baseSupply()) / targetDebt;\n\n        // depositing into, or getting info for, the created market uses this ID\n        id_ = markets.length;\n\n        markets.push(\n            Market({\n                quoteToken: _quoteToken,\n                capacityInQuote: _booleans[0],\n                capacity: _market[0],\n                totalDebt: targetDebt,\n                maxPayout: maxPayout,\n                purchased: 0,\n                sold: 0\n            })\n        );\n\n        terms.push(\n            Terms({\n                fixedTerm: _booleans[1],\n                controlVariable: uint64(controlVariable),\n                vesting: uint48(_terms[0]),\n                conclusion: uint48(_terms[1]),\n                maxDebt: uint64(maxDebt)\n            })\n        );\n\n        metadata.push(\n            Metadata({\n                lastTune: uint48(block.timestamp),\n                lastDecay: uint48(block.timestamp),\n                length: uint48(secondsToConclusion),\n                depositInterval: _intervals[0],\n                tuneInterval: _intervals[1],\n                quoteDecimals: uint8(decimals)\n            })\n        );\n\n        marketsForQuote[address(_quoteToken)].push(id_);\n\n        emit CreateMarket(id_, address(ohm), address(_quoteToken), _market[1]);\n    }\n\n    /**\n     * @notice             disable existing market\n     * @param _id          ID of market to close\n     */\n    function close(uint256 _id) external override onlyPolicy {\n        terms[_id].conclusion = uint48(block.timestamp);\n        markets[_id].capacity = 0;\n        emit CloseMarket(_id);\n    }\n\n    /* ======== EXTERNAL VIEW ======== */\n\n    /**\n     * @notice             calculate current market price of quote token in base token\n     * @dev                accounts for debt and control variable decay since last deposit (vs _marketPrice())\n     * @param _id          ID of market\n     * @return             price for market in OHM decimals\n     *\n     * price is derived from the equation\n     *\n     * p = cv * dr\n     *\n     * where\n     * p = price\n     * cv = control variable\n     * dr = debt ratio\n     *\n     * dr = d / s\n     *\n     * where\n     * d = debt\n     * s = supply of token at market creation\n     *\n     * d -= ( d * (dt / l) )\n     *\n     * where\n     * dt = change in time\n     * l = length of program\n     */\n    function marketPrice(uint256 _id) public view override returns (uint256) {\n        return (currentControlVariable(_id) * debtRatio(_id)) / (10**metadata[_id].quoteDecimals);\n    }\n\n    /**\n     * @notice             payout due for amount of quote tokens\n     * @dev                accounts for debt and control variable decay so it is up to date\n     * @param _amount      amount of quote tokens to spend\n     * @param _id          ID of market\n     * @return             amount of OHM to be paid in OHM decimals\n     *\n     * @dev 1e18 = ohm decimals (9) + market price decimals (9)\n     */\n    function payoutFor(uint256 _amount, uint256 _id) external view override returns (uint256) {\n        Metadata memory meta = metadata[_id];\n        return (_amount * 1e18) / marketPrice(_id) / 10**meta.quoteDecimals;\n    }\n\n    /**\n     * @notice             calculate current ratio of debt to supply\n     * @dev                uses current debt, which accounts for debt decay since last deposit (vs _debtRatio())\n     * @param _id          ID of market\n     * @return             debt ratio for market in quote decimals\n     */\n    function debtRatio(uint256 _id) public view override returns (uint256) {\n        return (currentDebt(_id) * (10**metadata[_id].quoteDecimals)) / treasury.baseSupply();\n    }\n\n    /**\n     * @notice             calculate debt factoring in decay\n     * @dev                accounts for debt decay since last deposit\n     * @param _id          ID of market\n     * @return             current debt for market in OHM decimals\n     */\n    function currentDebt(uint256 _id) public view override returns (uint256) {\n        return markets[_id].totalDebt - debtDecay(_id);\n    }\n\n    /**\n     * @notice             amount of debt to decay from total debt for market ID\n     * @param _id          ID of market\n     * @return             amount of debt to decay\n     */\n    function debtDecay(uint256 _id) public view override returns (uint64) {\n        Metadata memory meta = metadata[_id];\n\n        uint256 secondsSince = block.timestamp - meta.lastDecay;\n\n        return uint64((markets[_id].totalDebt * secondsSince) / meta.length);\n    }\n\n    /**\n     * @notice             up to date control variable\n     * @dev                accounts for control variable adjustment\n     * @param _id          ID of market\n     * @return             control variable for market in OHM decimals\n     */\n    function currentControlVariable(uint256 _id) public view returns (uint256) {\n        (uint64 decay, , ) = _controlDecay(_id);\n        return terms[_id].controlVariable - decay;\n    }\n\n    /**\n     * @notice             is a given market accepting deposits\n     * @param _id          ID of market\n     */\n    function isLive(uint256 _id) public view override returns (bool) {\n        return (markets[_id].capacity != 0 && terms[_id].conclusion > block.timestamp);\n    }\n\n    /**\n     * @notice returns an array of all active market IDs\n     */\n    function liveMarkets() external view override returns (uint256[] memory) {\n        uint256 num;\n        for (uint256 i = 0; i < markets.length; i++) {\n            if (isLive(i)) num++;\n        }\n\n        uint256[] memory ids = new uint256[](num);\n        uint256 nonce;\n        for (uint256 i = 0; i < markets.length; i++) {\n            if (isLive(i)) {\n                ids[nonce] = i;\n                nonce++;\n            }\n        }\n        return ids;\n    }\n\n    /**\n     * @notice             returns an array of all active market IDs for a given quote token\n     * @param _token       quote token to check for\n     */\n    function liveMarketsFor(address _token) external view override returns (uint256[] memory) {\n        uint256[] memory mkts = marketsForQuote[_token];\n        uint256 num;\n\n        for (uint256 i = 0; i < mkts.length; i++) {\n            if (isLive(mkts[i])) num++;\n        }\n\n        uint256[] memory ids = new uint256[](num);\n        uint256 nonce;\n\n        for (uint256 i = 0; i < mkts.length; i++) {\n            if (isLive(mkts[i])) {\n                ids[nonce] = mkts[i];\n                nonce++;\n            }\n        }\n        return ids;\n    }\n\n    /* ======== INTERNAL VIEW ======== */\n\n    /**\n     * @notice                  calculate current market price of quote token in base token\n     * @dev                     see marketPrice() for explanation of price computation\n     * @dev                     uses info from storage because data has been updated before call (vs marketPrice())\n     * @param _id               market ID\n     * @return                  price for market in OHM decimals\n     */\n    function _marketPrice(uint256 _id) internal view returns (uint256) {\n        return (terms[_id].controlVariable * _debtRatio(_id)) / (10**metadata[_id].quoteDecimals);\n    }\n\n    /**\n     * @notice                  calculate debt factoring in decay\n     * @dev                     uses info from storage because data has been updated before call (vs debtRatio())\n     * @param _id               market ID\n     * @return                  current debt for market in quote decimals\n     */\n    function _debtRatio(uint256 _id) internal view returns (uint256) {\n        return (markets[_id].totalDebt * (10**metadata[_id].quoteDecimals)) / treasury.baseSupply();\n    }\n\n    /**\n     * @notice                  amount to decay control variable by\n     * @param _id               ID of market\n     * @return decay_           change in control variable\n     * @return secondsSince_    seconds since last change in control variable\n     * @return active_          whether or not change remains active\n     */\n    function _controlDecay(uint256 _id)\n        internal\n        view\n        returns (\n            uint64 decay_,\n            uint48 secondsSince_,\n            bool active_\n        )\n    {\n        Adjustment memory info = adjustments[_id];\n        if (!info.active) return (0, 0, false);\n\n        secondsSince_ = uint48(block.timestamp) - info.lastAdjustment;\n\n        active_ = secondsSince_ < info.timeToAdjusted;\n        decay_ = active_ ? (info.change * secondsSince_) / info.timeToAdjusted : info.change;\n    }\n}\n"
    },
    "contracts/interfaces/IAggregatorV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n    @title AggregatorV3Interface\n    @notice Copied directly from chainlink website as standard interface for oracles\n */\ninterface AggregatorV3Interface {\n    function decimals() external view returns (uint8);\n\n    function description() external view returns (string memory);\n\n    function version() external view returns (uint256);\n\n    // getRoundData and latestRoundData should both raise \"No data present\"\n    // if they do not have data to report, instead of returning unset values\n    // which could be misinterpreted as actual reported values.\n    function getRoundData(uint80 _roundId)\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n"
    },
    "contracts/interfaces/IAllocator.sol": {
      "content": "pragma solidity >=0.8.0;\n\n// interfaces\nimport \"./IERC20.sol\";\nimport \"./ITreasuryExtender.sol\";\nimport \"./IOlympusAuthority.sol\";\n\nenum AllocatorStatus {\n    OFFLINE,\n    ACTIVATED,\n    MIGRATING\n}\n\nstruct AllocatorInitData {\n    IOlympusAuthority authority;\n    ITreasuryExtender extender;\n    IERC20[] tokens;\n}\n\n/**\n * @title Interface for the BaseAllocator\n * @dev\n *  These are the standard functions that an Allocator should implement. A subset of these functions\n *  is implemented in the `BaseAllocator`. Similar to those implemented, if for some reason the developer\n *  decides to implement a dedicated base contract, or not at all and rather a dedicated Allocator contract\n *  without base, imitate the functionalities implemented in it.\n */\ninterface IAllocator {\n    /**\n     * @notice\n     *  Emitted when the Allocator is deployed.\n     */\n    event AllocatorDeployed(address authority, address extender);\n\n    /**\n     * @notice\n     *  Emitted when the Allocator is activated.\n     */\n    event AllocatorActivated();\n\n    /**\n     * @notice\n     *  Emitted when the Allocator is deactivated.\n     */\n    event AllocatorDeactivated(bool panic);\n\n    /**\n     * @notice\n     *  Emitted when the Allocators loss limit is violated.\n     */\n    event LossLimitViolated(uint128 lastLoss, uint128 dloss, uint256 estimatedTotalAllocated);\n\n    /**\n     * @notice\n     *  Emitted when a Migration is executed.\n     * @dev\n     *  After this also `AllocatorDeactivated` should follow.\n     */\n    event MigrationExecuted(address allocator);\n\n    /**\n     * @notice\n     *  Emitted when Ether is received by the contract.\n     * @dev\n     *  Only the Guardian is able to send the ether.\n     */\n    event EtherReceived(uint256 amount);\n\n    function update(uint256 id) external;\n\n    function deallocate(uint256[] memory amounts) external;\n\n    function prepareMigration() external;\n\n    function migrate() external;\n\n    function activate() external;\n\n    function deactivate(bool panic) external;\n\n    function addId(uint256 id) external;\n\n    function name() external view returns (string memory);\n\n    function ids() external view returns (uint256[] memory);\n\n    function tokenIds(uint256 id) external view returns (uint256);\n\n    function version() external view returns (string memory);\n\n    function status() external view returns (AllocatorStatus);\n\n    function tokens() external view returns (IERC20[] memory);\n\n    function utilityTokens() external view returns (IERC20[] memory);\n\n    function rewardTokens() external view returns (IERC20[] memory);\n\n    function amountAllocated(uint256 id) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IBondDepository.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./IERC20.sol\";\n\ninterface IBondDepository {\n    // Info about each type of market\n    struct Market {\n        uint256 capacity; // capacity remaining\n        IERC20 quoteToken; // token to accept as payment\n        bool capacityInQuote; // capacity limit is in payment token (true) or in OHM (false, default)\n        uint64 totalDebt; // total debt from market\n        uint64 maxPayout; // max tokens in/out (determined by capacityInQuote false/true, respectively)\n        uint64 sold; // base tokens out\n        uint256 purchased; // quote tokens in\n    }\n\n    // Info for creating new markets\n    struct Terms {\n        bool fixedTerm; // fixed term or fixed expiration\n        uint64 controlVariable; // scaling variable for price\n        uint48 vesting; // length of time from deposit to maturity if fixed-term\n        uint48 conclusion; // timestamp when market no longer offered (doubles as time when market matures if fixed-expiry)\n        uint64 maxDebt; // 9 decimal debt maximum in OHM\n    }\n\n    // Additional info about market.\n    struct Metadata {\n        uint48 lastTune; // last timestamp when control variable was tuned\n        uint48 lastDecay; // last timestamp when market was created and debt was decayed\n        uint48 length; // time from creation to conclusion. used as speed to decay debt.\n        uint48 depositInterval; // target frequency of deposits\n        uint48 tuneInterval; // frequency of tuning\n        uint8 quoteDecimals; // decimals of quote token\n    }\n\n    // Control variable adjustment data\n    struct Adjustment {\n        uint64 change;\n        uint48 lastAdjustment;\n        uint48 timeToAdjusted;\n        bool active;\n    }\n\n    /**\n     * @notice deposit market\n     * @param _bid uint256\n     * @param _amount uint256\n     * @param _maxPrice uint256\n     * @param _user address\n     * @param _referral address\n     * @return payout_ uint256\n     * @return expiry_ uint256\n     * @return index_ uint256\n     */\n    function deposit(\n        uint256 _bid,\n        uint256 _amount,\n        uint256 _maxPrice,\n        address _user,\n        address _referral\n    )\n        external\n        returns (\n            uint256 payout_,\n            uint256 expiry_,\n            uint256 index_\n        );\n\n    function create(\n        IERC20 _quoteToken, // token used to deposit\n        uint256[3] memory _market, // [capacity, initial price]\n        bool[2] memory _booleans, // [capacity in quote, fixed term]\n        uint256[2] memory _terms, // [vesting, conclusion]\n        uint32[2] memory _intervals // [deposit interval, tune interval]\n    ) external returns (uint256 id_);\n\n    function close(uint256 _id) external;\n\n    function isLive(uint256 _bid) external view returns (bool);\n\n    function liveMarkets() external view returns (uint256[] memory);\n\n    function liveMarketsFor(address _quoteToken) external view returns (uint256[] memory);\n\n    function payoutFor(uint256 _amount, uint256 _bid) external view returns (uint256);\n\n    function marketPrice(uint256 _bid) external view returns (uint256);\n\n    function currentDebt(uint256 _bid) external view returns (uint256);\n\n    function debtRatio(uint256 _bid) external view returns (uint256);\n\n    function debtDecay(uint256 _bid) external view returns (uint64);\n}\n"
    },
    "contracts/interfaces/IBondingCalculator.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\ninterface IBondingCalculator {\n    function markdown(address _LP) external view returns (uint256);\n\n    function valuation(address pair_, uint256 amount_) external view returns (uint256 _value);\n}\n"
    },
    "contracts/interfaces/IBondSDA.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport {IERC20} from \"./IERC20.sol\";\n\ninterface IBondSDA {\n    /// @notice                 Creates a new bond market\n    /// @param params_          Configuration data needed for market creation\n    /// @return id              ID of new bond market\n    function createMarket(bytes calldata params_) external returns (uint256);\n}\n"
    },
    "contracts/interfaces/IBondTeller.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport {IERC20} from \"./IERC20.sol\";\n\ninterface IBondTeller {\n    /// @notice             Instantiates a new fixed expiry bond token\n    /// @param payoutToken  Token received upon bonding\n    /// @param expiration   Expiry timestamp for the bond\n    function deploy(IERC20 payoutToken, uint48 expiration) external;\n\n    /// @notice             Mint bond tokens for a specific expiry\n    /// @param expiration   Expiry timestamp for the bond\n    /// @param capacity     Amount of bond tokens to mint\n    function create(\n        IERC20 payoutToken,\n        uint48 expiration,\n        uint256 capacity\n    ) external returns (IERC20, uint256);\n}\n"
    },
    "contracts/interfaces/IDistributor.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\ninterface IDistributor {\n    function triggerRebase() external;\n\n    function distribute() external;\n\n    function retrieveBounty() external returns (uint256);\n\n    function nextRewardFor(address who) external view returns (uint256);\n\n    function setBounty(uint256 _bounty) external;\n\n    function setPools(address[] calldata _pools) external;\n\n    function removePool(uint256 index, address pool) external;\n\n    function addPool(uint256 index, address pool) external;\n\n    function setAdjustment(\n        bool _add,\n        uint256 _rate,\n        uint256 _target\n    ) external;\n}\n"
    },
    "contracts/interfaces/IEasyAuction.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport {IERC20} from \"./IERC20.sol\";\n\ninterface IEasyAuction {\n    /// @notice                         Initiates an auction through Gnosis Auctions\n    /// @param tokenToSell              The token being sold\n    /// @param biddingToken             The token used to bid on the sale token and set its price\n    /// @param lastCancellation         The last timestamp a user can cancel their bid at\n    /// @param auctionEnd               The timestamp the auction ends at\n    /// @param auctionAmount            The number of sale tokens to sell\n    /// @param minimumTotalPurchased    The minimum number of sale tokens that need to be sold for the auction to finalize\n    /// @param minimumPurchaseAmount    The minimum purchase size in bidding tokens\n    /// @param minFundingThreshold      The minimal funding thresholding for finalizing settlement\n    /// @param isAtomicClosureAllowed   Can users call settleAuctionAtomically when end date has been reached\n    /// @param accessManager            The contract to manage an allowlist\n    /// @param accessManagerData        The data for managing an allowlist\n    function initiateAuction(\n        IERC20 tokenToSell,\n        IERC20 biddingToken,\n        uint256 lastCancellation,\n        uint256 auctionEnd,\n        uint96 auctionAmount,\n        uint96 minimumTotalPurchased,\n        uint256 minimumPurchaseAmount,\n        uint256 minFundingThreshold,\n        bool isAtomicClosureAllowed,\n        address accessManager,\n        bytes calldata accessManagerData\n    ) external returns (uint256);\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/interfaces/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./IERC20.sol\";\n\ninterface IERC20Metadata is IERC20 {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/interfaces/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.5;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as th xe allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "contracts/interfaces/IgOHM.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./IERC20.sol\";\n\ninterface IgOHM is IERC20 {\n    function mint(address _to, uint256 _amount) external;\n\n    function burn(address _from, uint256 _amount) external;\n\n    function index() external view returns (uint256);\n\n    function balanceFrom(uint256 _amount) external view returns (uint256);\n\n    function balanceTo(uint256 _amount) external view returns (uint256);\n\n    function migrate(address _staking, address _sOHM) external;\n}\n"
    },
    "contracts/interfaces/IGovernable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\ninterface IGovernable {\n    function governor() external view returns (address);\n\n    function renounceGovernor() external;\n\n    function pushGovernor(address newGovernor_) external;\n\n    function pullGovernor() external;\n}\n"
    },
    "contracts/interfaces/IGuardable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\ninterface IGuardable {\n    function guardian() external view returns (address);\n\n    function renounceGuardian() external;\n\n    function pushGuardian(address newGuardian_) external;\n\n    function pullGuardian() external;\n}\n"
    },
    "contracts/interfaces/INoteKeeper.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.7.5;\n\ninterface INoteKeeper {\n    // Info for market note\n    struct Note {\n        uint256 payout; // gOHM remaining to be paid\n        uint48 created; // time market was created\n        uint48 matured; // timestamp when market is matured\n        uint48 redeemed; // time market was redeemed\n        uint48 marketID; // market ID of deposit. uint48 to avoid adding a slot.\n    }\n\n    function redeem(\n        address _user,\n        uint256[] memory _indexes,\n        bool _sendgOHM\n    ) external returns (uint256);\n\n    function redeemAll(address _user, bool _sendgOHM) external returns (uint256);\n\n    function pushNote(address to, uint256 index) external;\n\n    function pullNote(address from, uint256 index) external returns (uint256 newIndex_);\n\n    function indexesFor(address _user) external view returns (uint256[] memory);\n\n    function pendingFor(address _user, uint256 _index) external view returns (uint256 payout_, bool matured_);\n}\n"
    },
    "contracts/interfaces/IOHM.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./IERC20.sol\";\n\ninterface IOHM is IERC20 {\n    function mint(address account_, uint256 amount_) external;\n\n    function burn(uint256 amount) external;\n\n    function burnFrom(address account_, uint256 amount_) external;\n}\n"
    },
    "contracts/interfaces/IOlympusAuthority.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\ninterface IOlympusAuthority {\n    /* ========== EVENTS ========== */\n\n    event GovernorPushed(address indexed from, address indexed to, bool _effectiveImmediately);\n    event GuardianPushed(address indexed from, address indexed to, bool _effectiveImmediately);\n    event PolicyPushed(address indexed from, address indexed to, bool _effectiveImmediately);\n    event VaultPushed(address indexed from, address indexed to, bool _effectiveImmediately);\n\n    event GovernorPulled(address indexed from, address indexed to);\n    event GuardianPulled(address indexed from, address indexed to);\n    event PolicyPulled(address indexed from, address indexed to);\n    event VaultPulled(address indexed from, address indexed to);\n\n    /* ========== VIEW ========== */\n\n    function governor() external view returns (address);\n\n    function guardian() external view returns (address);\n\n    function policy() external view returns (address);\n\n    function vault() external view returns (address);\n}\n"
    },
    "contracts/interfaces/IOracle.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\ninterface IOracle {\n    function getPrice(address _pool) external returns (uint256);\n}\n"
    },
    "contracts/interfaces/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\ninterface IOwnable {\n    function owner() external view returns (address);\n\n    function renounceManagement() external;\n\n    function pushManagement(address newOwner_) external;\n\n    function pullManagement() external;\n}\n"
    },
    "contracts/interfaces/IsOHM.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./IERC20.sol\";\n\ninterface IsOHM is IERC20 {\n    function rebase(uint256 ohmProfit_, uint256 epoch_) external returns (uint256);\n\n    function circulatingSupply() external view returns (uint256);\n\n    function gonsForBalance(uint256 amount) external view returns (uint256);\n\n    function balanceForGons(uint256 gons) external view returns (uint256);\n\n    function index() external view returns (uint256);\n\n    function toG(uint256 amount) external view returns (uint256);\n\n    function fromG(uint256 amount) external view returns (uint256);\n\n    function changeDebt(\n        uint256 amount,\n        address debtor,\n        bool add\n    ) external;\n\n    function debtBalances(address _address) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IStaking.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\ninterface IStaking {\n    function stake(\n        address _to,\n        uint256 _amount,\n        bool _rebasing,\n        bool _claim\n    ) external returns (uint256);\n\n    function claim(address _recipient, bool _rebasing) external returns (uint256);\n\n    function forfeit() external returns (uint256);\n\n    function toggleLock() external;\n\n    function unstake(\n        address _to,\n        uint256 _amount,\n        bool _trigger,\n        bool _rebasing\n    ) external returns (uint256);\n\n    function wrap(address _to, uint256 _amount) external returns (uint256 gBalance_);\n\n    function unwrap(address _to, uint256 _amount) external returns (uint256 sBalance_);\n\n    function rebase() external;\n\n    function index() external view returns (uint256);\n\n    function contractBalance() external view returns (uint256);\n\n    function totalStaked() external view returns (uint256);\n\n    function supplyInWarmup() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IStakingV1.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\ninterface IStakingV1 {\n    function unstake(uint256 _amount, bool _trigger) external;\n\n    function index() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/ITeller.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\ninterface ITeller {\n    function newBond(\n        address _bonder,\n        address _principal,\n        uint256 _principalPaid,\n        uint256 _payout,\n        uint256 _expires,\n        address _feo\n    ) external returns (uint256 index_);\n\n    function redeemAll(address _bonder) external returns (uint256);\n\n    function redeem(address _bonder, uint256[] memory _indexes) external returns (uint256);\n\n    function getReward() external;\n\n    function setFEReward(uint256 reward) external;\n\n    function updateIndexesFor(address _bonder) external;\n\n    function pendingFor(address _bonder, uint256 _index) external view returns (uint256);\n\n    function pendingForIndexes(address _bonder, uint256[] memory _indexes) external view returns (uint256 pending_);\n\n    function totalPendingFor(address _bonder) external view returns (uint256 pending_);\n\n    function percentVestedFor(address _bonder, uint256 _index) external view returns (uint256 percentVested_);\n}\n"
    },
    "contracts/interfaces/ITreasury.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\ninterface ITreasury {\n    function deposit(\n        uint256 _amount,\n        address _token,\n        uint256 _profit\n    ) external returns (uint256);\n\n    function withdraw(uint256 _amount, address _token) external;\n\n    function tokenValue(address _token, uint256 _amount) external view returns (uint256 value_);\n\n    function mint(address _recipient, uint256 _amount) external;\n\n    function manage(address _token, uint256 _amount) external;\n\n    function incurDebt(uint256 amount_, address token_) external;\n\n    function repayDebtWithReserve(uint256 amount_, address token_) external;\n\n    function excessReserves() external view returns (uint256);\n\n    function baseSupply() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/ITreasuryExtender.sol": {
      "content": "pragma solidity ^0.8.10;\n\nstruct AllocatorPerformance {\n    uint128 gain;\n    uint128 loss;\n}\n\nstruct AllocatorLimits {\n    uint128 allocated;\n    uint128 loss;\n}\n\nstruct AllocatorHoldings {\n    uint256 allocated;\n}\n\nstruct AllocatorData {\n    AllocatorHoldings holdings;\n    AllocatorLimits limits;\n    AllocatorPerformance performance;\n}\n\n/**\n * @title Interface for the TreasuryExtender\n */\ninterface ITreasuryExtender {\n    /**\n     * @notice\n     *  Emitted when a new Deposit is registered.\n     */\n    event NewDepositRegistered(address allocator, address token, uint256 id);\n\n    /**\n     * @notice\n     *  Emitted when an Allocator is funded\n     */\n    event AllocatorFunded(uint256 id, uint256 amount, uint256 value);\n\n    /**\n     * @notice\n     *  Emitted when allocated funds are withdrawn from an Allocator\n     */\n    event AllocatorWithdrawal(uint256 id, uint256 amount, uint256 value);\n\n    /**\n     * @notice\n     *  Emitted when rewards are withdrawn from an Allocator\n     */\n    event AllocatorRewardsWithdrawal(address allocator, uint256 amount, uint256 value);\n\n    /**\n     * @notice\n     *  Emitted when an Allocator reports a gain\n     */\n    event AllocatorReportedGain(uint256 id, uint128 gain);\n\n    /**\n     * @notice\n     *  Emitted when an Allocator reports a loss\n     */\n    event AllocatorReportedLoss(uint256 id, uint128 loss);\n\n    /**\n     * @notice\n     *  Emitted when an Allocator reports a migration\n     */\n    event AllocatorReportedMigration(uint256 id);\n\n    /**\n     * @notice\n     *  Emitted when an Allocator limits are modified\n     */\n    event AllocatorLimitsChanged(uint256 id, uint128 allocationLimit, uint128 lossLimit);\n\n    function registerDeposit(address newAllocator) external;\n\n    function setAllocatorLimits(uint256 id, AllocatorLimits memory limits) external;\n\n    function report(\n        uint256 id,\n        uint128 gain,\n        uint128 loss\n    ) external;\n\n    function requestFundsFromTreasury(uint256 id, uint256 amount) external;\n\n    function returnFundsToTreasury(uint256 id, uint256 amount) external;\n\n    function returnRewardsToTreasury(\n        uint256 id,\n        address token,\n        uint256 amount\n    ) external;\n\n    function getTotalAllocatorCount() external view returns (uint256);\n\n    function getAllocatorByID(uint256 id) external view returns (address);\n\n    function getAllocatorAllocated(uint256 id) external view returns (uint256);\n\n    function getAllocatorLimits(uint256 id) external view returns (AllocatorLimits memory);\n\n    function getAllocatorPerformance(uint256 id) external view returns (AllocatorPerformance memory);\n}\n"
    },
    "contracts/interfaces/ITreasuryV1.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\ninterface ITreasuryV1 {\n    function withdraw(uint256 amount, address token) external;\n\n    function manage(address token, uint256 amount) external;\n\n    function valueOf(address token, uint256 amount) external view returns (uint256);\n\n    function excessReserves() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IUniswapV2ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\ninterface IUniswapV2ERC20 {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./IUniswapV2ERC20.sol\";\n\ninterface IUniswapV2Pair is IUniswapV2ERC20 {\n    function token0() external pure returns (address);\n\n    function token1() external pure returns (address);\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function sync() external;\n}\n"
    },
    "contracts/interfaces/IUniswapV2Router.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\ninterface IUniswapV2Router {\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure returns (uint256 amountB);\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountOut);\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountIn);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\n}\n"
    },
    "contracts/interfaces/IWarmup.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\ninterface IWarmup {\n    function retrieve(address staker_, uint256 amount_) external;\n}\n"
    },
    "contracts/interfaces/IwsOHM.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./IERC20.sol\";\n\n// Old wsOHM interface\ninterface IwsOHM is IERC20 {\n    function wrap(uint256 _amount) external returns (uint256);\n\n    function unwrap(uint256 _amount) external returns (uint256);\n\n    function wOHMTosOHM(uint256 _amount) external view returns (uint256);\n\n    function sOHMTowOHM(uint256 _amount) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IYieldDirector.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.7.5;\n\ninterface IYieldDirector {\n    // Write Functions\n    function deposit(uint256 amount_, address recipient_) external returns (uint256);\n\n    function depositSohm(uint256 amount_, address recipient_) external returns (uint256);\n\n    function addToDeposit(uint256 depositId_, uint256 amount_) external;\n\n    function addToSohmDeposit(uint256 depositId_, uint256 amount_) external;\n\n    function withdrawPrincipal(uint256 depositId, uint256 amount_) external;\n\n    function withdrawPrincipalAsSohm(uint256 depositId_, uint256 amount_) external;\n\n    function withdrawAll() external;\n\n    function redeemYield(uint256 depositId_) external;\n\n    function redeemYieldAsSohm(uint256 depositId_) external;\n\n    function redeemAllYield() external;\n\n    function redeemAllYieldAsSohm() external;\n\n    // View Functions\n    function getRecipientIds(address recipient_) external view returns (uint256[] memory);\n\n    function depositsTo(address donor_, address recipient_) external view returns (uint256);\n\n    function getAllDeposits(address donor_) external view returns (address[] memory, uint256[] memory);\n\n    function totalDeposits(address donor_) external view returns (uint256);\n\n    function donatedTo(address donor_, address recipient_) external view returns (uint256);\n\n    function totalDonated(address donor_) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IYieldStreamer.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.10;\n\ninterface IYieldStreamer {\n    // Write Functions\n    function deposit(\n        uint256 amount_,\n        address recipient_,\n        uint128 paymentInterval_,\n        uint128 userMinimumDaiThreshold_\n    ) external;\n\n    function addToDeposit(uint256 id_, uint256 amount_) external;\n\n    function withdrawPrincipal(uint256 id_, uint256 amount_) external;\n\n    function withdrawYield(uint256 id_) external;\n\n    function withdrawAllYield() external;\n\n    function harvestStreamTokens(uint256 id_) external;\n\n    function updateUserMinThreshold(uint256 id_, uint128 threshold_) external;\n\n    function updatePaymentInterval(uint256 id_, uint128 paymentInterval) external;\n\n    function upkeep() external;\n\n    // View Functions\n    function upkeepEligibility() external view returns (uint256 numberOfDepositsEligible, uint256 amountOfYieldToSwap);\n\n    function getPrincipalInGOHM(uint256 id_) external view returns (uint256);\n\n    function getRecipientIds(address recipient_) external view returns (uint256[] memory);\n}\n"
    },
    "contracts/libraries/Address.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\n// TODO(zx): replace with OZ implementation.\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    // function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n    //     require(address(this).balance >= value, \"Address: insufficient balance for call\");\n    //     return _functionCallWithValue(target, data, value, errorMessage);\n    // }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 weiValue,\n        string memory errorMessage\n    ) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.3._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.3._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) private pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.7.5;\n\nimport {IERC20} from \"../interfaces/IERC20.sol\";\n\n/// @notice Safe IERC20 and ETH transfer library that safely handles missing return values.\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/libraries/TransferHelper.sol)\n/// Taken from Solmate\nlibrary SafeERC20 {\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, amount)\n        );\n\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(IERC20.transfer.selector, to, amount)\n        );\n\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(IERC20.approve.selector, to, amount)\n        );\n\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"APPROVE_FAILED\");\n    }\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        (bool success, ) = to.call{value: amount}(new bytes(0));\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n}\n"
    },
    "contracts/migration/BalancerLiquidityMigrator.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.10;\npragma abicoder v2;\n\nimport \"../libraries/SafeERC20.sol\";\n\nimport \"../interfaces/ITreasury.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IUniswapV2Router.sol\";\nimport \"../interfaces/IOlympusAuthority.sol\";\n\nimport \"../types/OlympusAccessControlled.sol\";\n\ninterface IBalancerVault {\n    /**\n     * @dev Called by users to join a Pool, which transfers tokens from `sender` into the Pool's balance. This will\n     * trigger custom Pool behavior, which will typically grant something in return to `recipient` - often tokenized\n     * Pool shares.\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * The `assets` and `maxAmountsIn` arrays must have the same length, and each entry indicates the maximum amount\n     * to send for each asset. The amounts to send are decided by the Pool and not the Vault: it just enforces\n     * these maximums.\n     *\n     * If joining a Pool that holds WETH, it is possible to send ETH directly: the Vault will do the wrapping. To enable\n     * this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead of the\n     * WETH address. Note that it is not possible to combine ETH and WETH in the same join. Any excess ETH will be sent\n     * back to the caller (not the sender, which is important for relayers).\n     *\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\n     * interacting with Pools that register and deregister tokens frequently. If sending ETH however, the array must be\n     * sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the final\n     * `assets` array might not be sorted. Pools with no registered tokens cannot be joined.\n     *\n     * If `fromInternalBalance` is true, the caller's Internal Balance will be preferred: ERC20 transfers will only\n     * be made for the difference between the requested amount and Internal Balance (if any). Note that ETH cannot be\n     * withdrawn from Internal Balance: attempting to do so will trigger a revert.\n     *\n     * This causes the Vault to call the `IBasePool.onJoinPool` hook on the Pool's contract, where Pools implement\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\n     * of Pool shares). This can be encoded in the `userData` argument, which is ignored by the Vault and passed\n     * directly to the Pool's contract, as is `recipient`.\n     *\n     * Emits a `PoolBalanceChanged` event.\n     */\n    function joinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        JoinPoolRequest memory request\n    ) external payable;\n\n    struct JoinPoolRequest {\n        address[] assets;\n        uint256[] maxAmountsIn;\n        bytes userData;\n        bool fromInternalBalance;\n    }\n}\n\ncontract BalancerLiquidityMigrator is OlympusAccessControlled {\n    using SafeERC20 for IERC20;\n\n    // Balancer Vault\n    IBalancerVault internal immutable balancerVault = IBalancerVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);\n\n    // Olympus Treasury\n    ITreasury internal immutable treasury = ITreasury(0x9A315BdF513367C0377FB36545857d12e85813Ef);\n\n    // Sushiswap Router\n    IUniswapV2Router internal immutable router = IUniswapV2Router(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);\n\n    // Balancer 50OHM-25DAI-25WETH poolID\n    bytes32 internal immutable balancerPoolID = 0xc45d42f801105e861e86658648e3678ad7aa70f900010000000000000000011e;\n\n    address internal immutable OHMETHSLP = 0x69b81152c5A8d35A67B32A4D3772795d96CaE4da;\n    address internal immutable OHMDAISLP = 0x055475920a8c93CfFb64d039A8205F7AcC7722d3;\n    address internal immutable OHM = 0x64aa3364F17a4D01c6f1751Fd97C2BD3D7e7f1D5;\n    address internal immutable WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address internal immutable DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n    constructor(IOlympusAuthority _authority) OlympusAccessControlled(_authority) {}\n\n    /**\n     * @notice Removes liquidity from OHM/ETH SLP and OHM/DAI SLP, then adds liquidty to\n     * 50OHM-25DAI-25WETH Balancer pool.\n     */\n    function moveLiquidity(\n        uint256 _amountOHMETH,\n        uint256 _amountOHMDAI,\n        uint256[2] memory _minOHMETH,\n        uint256[2] memory _minOHMDAI,\n        uint256 _deadline,\n        bytes memory _userData\n    ) external onlyGuardian {\n        // Manage LPs from treasury\n        treasury.manage(OHMETHSLP, _amountOHMETH);\n        treasury.manage(OHMDAISLP, _amountOHMDAI);\n\n        // Approve LPs to be spent by the Sushiswap router\n        IERC20(OHMETHSLP).approve(address(router), _amountOHMETH);\n        IERC20(OHMDAISLP).approve(address(router), _amountOHMDAI);\n\n        // Remove specified liquidity from OHM/ETH SLP\n        (uint256 amountETH, uint256 amountOHM1) = router.removeLiquidity(\n            WETH,\n            OHM,\n            _amountOHMETH,\n            _minOHMETH[0],\n            _minOHMETH[1],\n            address(this),\n            _deadline\n        );\n\n        // Remove specified liquidity from OHM/DAI SLP\n        (uint256 amountDAI, uint256 amountOHM2) = router.removeLiquidity(\n            DAI,\n            OHM,\n            _amountOHMDAI,\n            _minOHMDAI[0],\n            _minOHMDAI[1],\n            address(this),\n            _deadline\n        );\n\n        // Amount of OHM removed from liquidity\n        uint256 amountOHM = amountOHM1 + amountOHM2;\n\n        // Approve Balancer vault to spend tokens\n        IERC20(OHM).approve(address(balancerVault), amountOHM);\n        IERC20(WETH).approve(address(balancerVault), amountETH);\n        IERC20(DAI).approve(address(balancerVault), amountDAI);\n\n        // Array of tokens that liquidty will be added for\n        address[] memory tokens = new address[](3);\n        tokens[0] = OHM;\n        tokens[1] = DAI;\n        tokens[2] = WETH;\n\n        // Max amount of each token that liquidity will be added for\n        uint256[] memory amounts = new uint256[](3);\n        amounts[0] = amountOHM;\n        amounts[1] = amountDAI;\n        amounts[2] = amountETH;\n\n        // Struct that is passed in when adding to the pool\n        IBalancerVault.JoinPoolRequest memory poolRequest = IBalancerVault.JoinPoolRequest(\n            tokens,\n            amounts,\n            _userData,\n            false\n        );\n\n        // Add liquidity to the Balancer pool\n        balancerVault.joinPool(balancerPoolID, address(this), address(treasury), poolRequest);\n\n        // Send any leftover OHM back to guardian and WETH and DAI to treasury\n        IERC20(OHM).safeTransfer(authority.guardian(), IERC20(OHM).balanceOf(address(this)));\n        IERC20(WETH).safeTransfer(address(treasury), IERC20(WETH).balanceOf(address(this)));\n        IERC20(DAI).safeTransfer(address(treasury), IERC20(DAI).balanceOf(address(this)));\n    }\n}\n"
    },
    "contracts/migration/CurveLiquidityMigrator.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.10;\n\nimport \"../libraries/SafeERC20.sol\";\n\nimport \"../interfaces/ITreasury.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IUniswapV2Router.sol\";\nimport \"../interfaces/IOlympusAuthority.sol\";\n\nimport \"../types/OlympusAccessControlled.sol\";\n\ninterface ICurvePool {\n    function add_liquidity(\n        uint256[2] memory amounts,\n        uint256 min_mint_amount,\n        bool use_eth,\n        address receiver\n    ) external payable returns (uint256);\n}\n\n/// @title   Curve Liquidity Migrator\n/// @notice  Migrates from OHM/ETH SLP to the OHM/ETH Curve pool\n/// @author  JeffX\ncontract CurveLiquidityMigrator is OlympusAccessControlled {\n    using SafeERC20 for IERC20;\n\n    /// STATE VARIABLES ///\n\n    ICurvePool internal immutable curvePool = ICurvePool(0x6ec38b3228251a0C5D491Faf66858e2E23d7728B);\n    ITreasury internal immutable treasury = ITreasury(0x9A315BdF513367C0377FB36545857d12e85813Ef);\n    IUniswapV2Router internal immutable router = IUniswapV2Router(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);\n\n    address internal immutable OHMETHSLP = 0x69b81152c5A8d35A67B32A4D3772795d96CaE4da;\n    address internal immutable OHM = 0x64aa3364F17a4D01c6f1751Fd97C2BD3D7e7f1D5;\n    address internal immutable WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    /// CONSTRUCTOR ///\n\n    /// @param _authority  Address of the Olympus Authority contract\n    constructor(IOlympusAuthority _authority) OlympusAccessControlled(_authority) {}\n\n    /// POLICY FUNCTION ///\n\n    /// @notice                 Removes OHM/ETH SLP and adds to Curve pool\n    /// @param _amountToRemove  Amount of OHM/ETH SLP to remove\n    /// @param _minRemoval      Array of min amounts of OHM and ETH to recieve back\n    /// @param _minMintAmount   Min amount of OHM/ETH Curve pool tokens to recieve back.\n    function moveLiquidity(\n        uint256 _amountToRemove,\n        uint256[2] memory _minRemoval,\n        uint256 _minMintAmount\n    ) external onlyGuardian {\n        // Remove LP From Treasury\n        treasury.manage(OHMETHSLP, _amountToRemove);\n\n        // Approve LP to be spent by the Sushiswap router\n        IERC20(OHMETHSLP).approve(address(router), _amountToRemove);\n\n        // Remove specified liquidity from OHM/ETH SLP\n        (uint256 amountOHM, uint256 amountWETH) = router.removeLiquidity(\n            OHM,\n            WETH,\n            _amountToRemove,\n            _minRemoval[0],\n            _minRemoval[1],\n            address(this),\n            10000000000000000\n        );\n\n        // Approve curve pool vault to spend tokens\n        IERC20(OHM).approve(address(curvePool), amountOHM);\n        IERC20(WETH).approve(address(curvePool), amountWETH);\n\n        // Add liquidity to the curve pool\n        curvePool.add_liquidity([amountOHM, amountWETH], _minMintAmount, false, address(treasury));\n\n        // Send any leftover OHM back to guardian and WETH to treasury\n        IERC20(OHM).safeTransfer(authority.guardian(), IERC20(OHM).balanceOf(address(this)));\n        IERC20(WETH).safeTransfer(address(treasury), IERC20(WETH).balanceOf(address(this)));\n    }\n}\n"
    },
    "contracts/migration/GelatoLiquidityMigrator.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.10;\npragma abicoder v2;\n\nimport \"../libraries/SafeERC20.sol\";\n\nimport \"../interfaces/ITreasury.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IUniswapV2Router.sol\";\nimport \"../interfaces/IOlympusAuthority.sol\";\n\nimport \"../types/OlympusAccessControlled.sol\";\n\ninterface IGUniRouter {\n    function addLiquidity(\n        address pool,\n        uint256 amount0Max,\n        uint256 amount1Max,\n        uint256 amount0Min,\n        uint256 amount1Min,\n        address receiver\n    ) external;\n}\n\ncontract GelatoLiquidityMigrator is OlympusAccessControlled {\n    using SafeERC20 for IERC20;\n\n    // GUni Router\n    IGUniRouter internal immutable gUniRouter = IGUniRouter(0x513E0a261af2D33B46F98b81FED547608fA2a03d);\n\n    // Olympus Treasury\n    ITreasury internal immutable treasury = ITreasury(0x9A315BdF513367C0377FB36545857d12e85813Ef);\n\n    // Uniswap Router\n    IUniswapV2Router internal immutable router = IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n\n    address internal immutable OHMFRAXGUniPool = 0x61a0C8d4945A61bF26c13e07c30AF1f1ca67b473;\n    address internal immutable OHMFRAXLP = 0xB612c37688861f1f90761DC7F382C2aF3a50Cc39;\n    address internal immutable OHM = 0x64aa3364F17a4D01c6f1751Fd97C2BD3D7e7f1D5;\n    address internal immutable FRAX = 0x853d955aCEf822Db058eb8505911ED77F175b99e;\n\n    constructor(IOlympusAuthority _authority) OlympusAccessControlled(_authority) {}\n\n    /**\n     * @notice Removes liquidity from OHM/FRAX LP, then adds liquidty to\n     * OHM/FRAX GUni\n     */\n    function moveLiquidity(\n        uint256 _amountOHMFRAX,\n        uint256[2] calldata _minOHMFRAXLP,\n        uint256[2] calldata _minOHMFRAXGUni,\n        uint256 _deadline\n    ) external onlyGuardian {\n        // Manage LP from treasury\n        treasury.manage(OHMFRAXLP, _amountOHMFRAX);\n\n        // Approve LP to be spent by the uni router\n        IERC20(OHMFRAXLP).approve(address(router), _amountOHMFRAX);\n\n        // Remove specified liquidity from OHM/FRAX LP\n        (uint256 amountOHM, uint256 amountFRAX) = router.removeLiquidity(\n            OHM,\n            FRAX,\n            _amountOHMFRAX,\n            _minOHMFRAXLP[0],\n            _minOHMFRAXLP[1],\n            address(this),\n            _deadline\n        );\n\n        // Approve Balancer vault to spend tokens\n        IERC20(OHM).approve(address(gUniRouter), amountOHM);\n        IERC20(FRAX).approve(address(gUniRouter), amountFRAX);\n\n        gUniRouter.addLiquidity(\n            OHMFRAXGUniPool,\n            amountOHM,\n            amountFRAX,\n            _minOHMFRAXGUni[0],\n            _minOHMFRAXGUni[1],\n            address(treasury)\n        );\n\n        // Send any leftover OHM back to guardian and FRAX to treasury\n        IERC20(OHM).safeTransfer(authority.guardian(), IERC20(OHM).balanceOf(address(this)));\n        IERC20(FRAX).safeTransfer(address(treasury), IERC20(FRAX).balanceOf(address(this)));\n    }\n}\n"
    },
    "contracts/migration/LUSDSwap.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.10;\npragma abicoder v2;\n\nimport \"../libraries/SafeERC20.sol\";\n\nimport \"../interfaces/ITreasury.sol\";\nimport \"../interfaces/ITreasuryV1.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IOlympusAuthority.sol\";\n\nimport \"../types/OlympusAccessControlled.sol\";\n\ninterface ICurveFactory {\n    function exchange_underlying(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external returns (uint256);\n}\n\n/// @title   LUSD Swap Contract\n/// @notice  Swaps LUSD from treasury v1 to DAI then sends to treasury v2\n/// @author  JeffX\ncontract LUSDSwapContract is OlympusAccessControlled {\n    using SafeERC20 for IERC20;\n\n    /// ERRORS ///\n\n    /// @notice Error for if more DAI than 1:1 backing is attempted to be sent\n    error OverOHMV1Backing();\n\n    /// STATE VARIABLES ///\n\n    /// @notice Curve Factory\n    ICurveFactory internal immutable curveFactory = ICurveFactory(0xEd279fDD11cA84bEef15AF5D39BB4d4bEE23F0cA);\n    /// @notice Olympus Treasury V1\n    ITreasuryV1 internal immutable treasuryV1 = ITreasuryV1(0x31F8Cc382c9898b273eff4e0b7626a6987C846E8);\n    /// @notice Olympus Treasury V2\n    ITreasury internal immutable treasuryV2 = ITreasury(0x9A315BdF513367C0377FB36545857d12e85813Ef);\n    /// @notice Olympus Token V1\n    IERC20 internal immutable OHMV1 = IERC20(0x383518188C0C6d7730D91b2c03a03C837814a899);\n    /// @notice LUSD\n    address internal immutable LUSD = 0x5f98805A4E8be255a32880FDeC7F6728C6568bA0;\n    /// @notice DAI\n    address internal immutable DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    /// @notice Remaining amount of DAI to have each OHM V1 backed by 1 DAI;\n    uint256 public OHMV1BackingInDAIRemaining;\n\n    /// CONSTRUCTOR ///\n\n    /// @param _authority  Address of the Olympus Authority contract\n    constructor(IOlympusAuthority _authority) OlympusAccessControlled(_authority) {\n        OHMV1BackingInDAIRemaining = OHMV1.totalSupply() * 1e9;\n    }\n\n    /// POLICY FUNCTIONS ///\n\n    /// @notice                        Manages LUSD from treasury V1 and swaps for LUSD\n    /// @param _amountLUSD             Amount of LUSD that will be managed from treasury V1 and swapped\n    /// @param _minAmountDAI           Minimum amount of DAI to receive\n    /// @param _amountDAIToV1Treasury  Amount of DAI that was received from swap to be sent to V1 treasury\n    function swapLUSDForDAI(\n        uint256 _amountLUSD,\n        uint256 _minAmountDAI,\n        uint256 _amountDAIToV1Treasury\n    ) external onlyGuardian {\n        // Manage LUSD from v1 treasury\n        treasuryV1.manage(LUSD, _amountLUSD);\n\n        // Approve LUSD to be spent by the  Curve pool\n        IERC20(LUSD).approve(address(curveFactory), _amountLUSD);\n\n        // Swap specified LUSD for DAI\n        uint256 daiReceived = curveFactory.exchange_underlying(0, 1, _amountLUSD, _minAmountDAI);\n\n        if (_amountDAIToV1Treasury > 0) {\n            if (OHMV1BackingInDAIRemaining < _amountDAIToV1Treasury) revert OverOHMV1Backing();\n            IERC20(DAI).safeTransfer(address(treasuryV1), _amountDAIToV1Treasury);\n            OHMV1BackingInDAIRemaining -= _amountDAIToV1Treasury;\n            daiReceived -= _amountDAIToV1Treasury;\n        }\n\n        IERC20(DAI).approve(address(treasuryV2), daiReceived);\n\n        // Deposit DAI into v2 treasury, all as profit\n        treasuryV2.deposit(daiReceived, DAI, treasuryV2.tokenValue(DAI, daiReceived));\n    }\n}\n"
    },
    "contracts/mocks/MockAllocators.sol": {
      "content": "pragma solidity ^0.8.10;\n\n// interfaces\nimport \"../interfaces/IAllocator.sol\";\n\n// types\nimport \"../types/BaseAllocator.sol\";\n\ncontract SimplestMockAllocator is BaseAllocator {\n    address public constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n    uint128 public gains;\n    uint128 public losses;\n\n    event PanicTriggered();\n\n    constructor(AllocatorInitData memory data) BaseAllocator(data) {}\n\n    function setGL(uint128 gain, uint128 loss) public {\n        gains = gain;\n        losses = loss;\n    }\n\n    function _update(uint256 id) internal override returns (uint128 gain, uint128 loss) {\n        gain = gains;\n        loss = losses;\n    }\n\n    function deallocate(uint256[] memory amounts) public override {}\n\n    function _deactivate(bool panic) internal override {\n        if (panic) emit PanicTriggered();\n    }\n\n    function _prepareMigration() internal override {}\n\n    function amountAllocated(uint256 id) public view override returns (uint256) {\n        return _tokens[id].balanceOf(address(this));\n    }\n\n    function rewardTokens() public view override returns (IERC20[] memory) {\n        IERC20[] memory coin = new IERC20[](1);\n        coin[0] = IERC20(DAI);\n        return coin;\n    }\n\n    function utilityTokens() public view override returns (IERC20[] memory) {\n        IERC20[] memory coin = new IERC20[](1);\n        coin[0] = IERC20(DAI);\n        return coin;\n    }\n\n    function name() external view override returns (string memory) {\n        return \"SimpleFraxAllocator\";\n    }\n}\n"
    },
    "contracts/mocks/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\n\ncontract MockERC20 is ERC20 {\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) ERC20(_name, _symbol, _decimals) {}\n\n    function mint(address to, uint256 value) public virtual {\n        _mint(to, value);\n    }\n\n    function burn(address from, uint256 value) public virtual {\n        _burn(from, value);\n    }\n}\n"
    },
    "contracts/mocks/MockGohm.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\n//import {IgOHM} from \"../interfaces/IgOHM.sol\";\nimport {MockERC20} from \"./MockERC20.sol\";\n\n// TODO fulfills IgOHM but is not inheriting because of dependency issues\ncontract MockGOhm is MockERC20 {\n    /* ========== CONSTRUCTOR ========== */\n\n    uint256 public immutable index;\n\n    constructor(uint256 _initIndex) MockERC20(\"Governance OHM\", \"gOHM\", 18) {\n        index = _initIndex;\n    }\n\n    function migrate(address _staking, address _sOhm) external {}\n\n    function balanceFrom(uint256 _amount) public view returns (uint256) {\n        return (_amount * index) / 10**decimals;\n    }\n\n    function balanceTo(uint256 _amount) public view returns (uint256) {\n        return (_amount * (10**decimals)) / index;\n    }\n}\n"
    },
    "contracts/mocks/MockSOHM.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"hardhat/console.sol\";\n\n/**\n * A mock version of sOHM, with an over-simplified rebase mechanism, for testing purposes only\n */\ncontract MockSOHM is ERC20 {\n    uint256 public immutable DECIMALS;\n    uint256 public _index; // 9 decimals\n    uint256 public _rebasePct; // 9 decimals\n    uint256 public _totalAgnosticSupply;\n\n    mapping(address => uint256) public _agnosticBalance;\n    mapping(address => mapping(address => uint256)) public _allowedValue;\n\n    constructor(uint256 initialIndex_, uint256 rebasePct_) ERC20(\"Mock sOHM\", \"sOHM\") {\n        require(initialIndex_ > 0, \"initial index must be greater than 0\");\n        require(rebasePct_ > 0, \"rebase percentage must be greater than 0\");\n\n        DECIMALS = 10**decimals();\n        _index = initialIndex_;\n        _rebasePct = rebasePct_;\n    }\n\n    function decimals() public pure override returns (uint8) {\n        return 9;\n    }\n\n    function approve(address spender_, uint256 value_) public override returns (bool) {\n        _approve(msg.sender, spender_, value_);\n        return true;\n    }\n\n    function mint(address to_, uint256 amount_) public returns (uint256) {\n        uint256 amount = (amount_ * DECIMALS) / _index;\n\n        _agnosticBalance[to_] += amount;\n        _mint(to_, amount);\n        _totalAgnosticSupply += amount;\n        return amount;\n    }\n\n    function transfer(address to_, uint256 value_) public override returns (bool) {\n        require(to_ != address(0), \"ERC20: transfer to the zero address\");\n\n        _transfer(msg.sender, to_, value_);\n        return true;\n    }\n\n    function transferFrom(\n        address from_,\n        address to_,\n        uint256 value_\n    ) public override returns (bool) {\n        require(from_ != address(0), \"ERC20: transfer from the zero address\");\n        require(to_ != address(0), \"ERC20: transfer to the zero address\");\n\n        _allowedValue[from_][to_] -= value_;\n        _transfer(from_, to_, value_);\n        return true;\n    }\n\n    function _transfer(\n        address from_,\n        address to_,\n        uint256 value_\n    ) internal override {\n        uint256 amount = (value_ * DECIMALS) / _index;\n\n        _agnosticBalance[from_] -= amount;\n        _agnosticBalance[to_] += amount;\n\n        emit Transfer(from_, to_, amount);\n    }\n\n    function balanceOf(address owner_) public view override returns (uint256) {\n        return (_agnosticBalance[owner_] * _index) / DECIMALS;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return (_totalAgnosticSupply * _index) / DECIMALS;\n    }\n\n    // Rebase all balances by rebase percentage\n    function rebase() external {\n        _index += (_index * _rebasePct) / DECIMALS;\n    }\n\n    // Set rebase percentage to new amount. Percentage has 9 decimal places.\n    function setRebasePct(uint256 newRebasePct_) external {\n        require(newRebasePct_ > 0, \"rebase percentage must be greater than 0\");\n        _rebasePct = newRebasePct_;\n    }\n\n    function index() public view returns (uint256) {\n        return _index;\n    }\n\n    // Set index. Index has 9 decimal places.\n    function setIndex(uint256 newIndex_) external {\n        require(newIndex_ > 0, \"new index must be greater than 0\");\n        _index = newIndex_;\n    }\n\n    // Drip 100 sOHM to caller\n    function drip() external {\n        mint(msg.sender, 100000000000);\n    }\n\n    function _approve(\n        address owner_,\n        address spender_,\n        uint256 value_\n    ) internal override {\n        _allowedValue[owner_][spender_] = value_;\n        emit Approval(owner_, spender_, value_);\n    }\n}\n"
    },
    "contracts/mocks/YieldSplitterImplementation.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport {YieldSplitter} from \"../types/YieldSplitter.sol\";\nimport {IgOHM} from \"../interfaces/IgOHM.sol\";\n\n/**\n    @title YieldSplitterImpl\n    @notice Implements the abstract contract Yield Splitter by making all the internal functions public for testing purposes.\n*/\ncontract YieldSplitterImpl is YieldSplitter {\n    /**\n    @notice Constructor\n    @param sOHM_ Address of sOHM.\n    */\n    constructor(address sOHM_, address authority_) YieldSplitter(sOHM_, authority_) {}\n\n    /**\n        @notice Create a deposit.\n        @param depositor_ Address of depositor\n        @param amount_ Amount in gOhm. 18 decimals.\n    */\n    function deposit(address depositor_, uint256 amount_) external returns (uint256 depositId) {\n        depositId = _deposit(depositor_, amount_);\n    }\n\n    /**\n        @notice Add more gOhm to the depositor's principal deposit.\n        @param id_ Id of the deposit.\n        @param amount_ Amount of gOhm to add. 18 decimals.\n    */\n    function addToDeposit(uint256 id_, uint256 amount_) external {\n        _addToDeposit(id_, amount_, msg.sender);\n    }\n\n    /**\n        @notice Withdraw part of the principal amount deposited.\n        @param id_ Id of the deposit.\n        @param amount_ Amount of gOHM to withdraw.\n    */\n    function withdrawPrincipal(uint256 id_, uint256 amount_) external {\n        _withdrawPrincipal(id_, amount_, msg.sender);\n    }\n\n    /**\n        @notice Withdraw all of the principal amount deposited.\n        @param id_ Id of the deposit.\n        @return amountWithdrawn : amount of gOHM withdrawn. 18 decimals.\n    */\n    function withdrawAllPrincipal(uint256 id_) external returns (uint256 amountWithdrawn) {\n        return _withdrawAllPrincipal(id_, msg.sender);\n    }\n\n    /**\n        @notice Redeem excess yield from your deposit in sOHM.\n        @param id_ Id of the deposit.\n        @return amountRedeemed : amount of yield redeemed in gOHM. 18 decimals.\n    */\n    function redeemYield(uint256 id_) external returns (uint256) {\n        return _redeemYield(id_);\n    }\n\n    /**\n        @notice Redeems yield from a deposit and sends it to the recipient\n        @param id_ Id of the deposit.\n    */\n    function redeemYieldOnBehalfOf(uint256 id_) external override returns (uint256) {\n        require(hasPermissionToRedeem[msg.sender], \"unauthorized\");\n        return _redeemYield(id_);\n    }\n\n    /**\n        @notice Close a deposit. Remove all information in both the deposit info, depositorIds and recipientIds.\n        @param id_ Id of the deposit.\n        @dev Internally for accounting reasons principal amount is stored in 9 decimal OHM terms. \n        Since most implementations will work will gOHM, principal here is returned externally in 18 decimal gOHM terms.\n        @return principal : amount of principal that was deleted. in gOHM. 18 decimals.\n        @return agnosticAmount : total amount of gOHM deleted. Principal + Yield. 18 decimals.\n    */\n    function closeDeposit(uint256 id_) external returns (uint256 principal, uint256 agnosticAmount) {\n        (principal, agnosticAmount) = _closeDeposit(id_, msg.sender);\n    }\n\n    /**\n        @notice Calculate outstanding yield redeemable based on principal and agnosticAmount.\n        @return uint256 amount of yield in gOHM. 18 decimals.\n     */\n    function getOutstandingYield(uint256 principal_, uint256 agnosticAmount_) external view returns (uint256) {\n        return _getOutstandingYield(principal_, agnosticAmount_);\n    }\n}\n"
    },
    "contracts/OlympusAuthority.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./interfaces/IOlympusAuthority.sol\";\n\nimport \"./types/OlympusAccessControlled.sol\";\n\ncontract OlympusAuthority is IOlympusAuthority, OlympusAccessControlled {\n    /* ========== STATE VARIABLES ========== */\n\n    address public override governor;\n\n    address public override guardian;\n\n    address public override policy;\n\n    address public override vault;\n\n    address public newGovernor;\n\n    address public newGuardian;\n\n    address public newPolicy;\n\n    address public newVault;\n\n    /* ========== Constructor ========== */\n\n    constructor(\n        address _governor,\n        address _guardian,\n        address _policy,\n        address _vault\n    ) OlympusAccessControlled(IOlympusAuthority(address(this))) {\n        governor = _governor;\n        emit GovernorPushed(address(0), governor, true);\n        guardian = _guardian;\n        emit GuardianPushed(address(0), guardian, true);\n        policy = _policy;\n        emit PolicyPushed(address(0), policy, true);\n        vault = _vault;\n        emit VaultPushed(address(0), vault, true);\n    }\n\n    /* ========== GOV ONLY ========== */\n\n    function pushGovernor(address _newGovernor, bool _effectiveImmediately) external onlyGovernor {\n        if (_effectiveImmediately) governor = _newGovernor;\n        newGovernor = _newGovernor;\n        emit GovernorPushed(governor, newGovernor, _effectiveImmediately);\n    }\n\n    function pushGuardian(address _newGuardian, bool _effectiveImmediately) external onlyGovernor {\n        if (_effectiveImmediately) guardian = _newGuardian;\n        newGuardian = _newGuardian;\n        emit GuardianPushed(guardian, newGuardian, _effectiveImmediately);\n    }\n\n    function pushPolicy(address _newPolicy, bool _effectiveImmediately) external onlyGovernor {\n        if (_effectiveImmediately) policy = _newPolicy;\n        newPolicy = _newPolicy;\n        emit PolicyPushed(policy, newPolicy, _effectiveImmediately);\n    }\n\n    function pushVault(address _newVault, bool _effectiveImmediately) external onlyGovernor {\n        if (_effectiveImmediately) vault = _newVault;\n        newVault = _newVault;\n        emit VaultPushed(vault, newVault, _effectiveImmediately);\n    }\n\n    /* ========== PENDING ROLE ONLY ========== */\n\n    function pullGovernor() external {\n        require(msg.sender == newGovernor, \"!newGovernor\");\n        emit GovernorPulled(governor, newGovernor);\n        governor = newGovernor;\n    }\n\n    function pullGuardian() external {\n        require(msg.sender == newGuardian, \"!newGuard\");\n        emit GuardianPulled(guardian, newGuardian);\n        guardian = newGuardian;\n    }\n\n    function pullPolicy() external {\n        require(msg.sender == newPolicy, \"!newPolicy\");\n        emit PolicyPulled(policy, newPolicy);\n        policy = newPolicy;\n    }\n\n    function pullVault() external {\n        require(msg.sender == newVault, \"!newVault\");\n        emit VaultPulled(vault, newVault);\n        vault = newVault;\n    }\n}\n"
    },
    "contracts/peripheral/OhmBondManager.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.15;\n\nimport {IBondSDA} from \"../interfaces/IBondSDA.sol\";\nimport {IBondTeller} from \"../interfaces/IBondTeller.sol\";\nimport {IEasyAuction} from \"../interfaces/IEasyAuction.sol\";\nimport {IERC20} from \"../interfaces/IERC20.sol\";\nimport {ITreasury} from \"../interfaces/ITreasury.sol\";\nimport {IOlympusAuthority} from \"../interfaces/IOlympusAuthority.sol\";\nimport {OlympusAccessControlled} from \"../types/OlympusAccessControlled.sol\";\n\ncontract OhmBondManager is OlympusAccessControlled {\n    // ========= DATA STRUCTURES ========= //\n    struct BondProtocolParameters {\n        uint256 initialPrice;\n        uint256 minPrice;\n        uint32 debtBuffer;\n        uint256 auctionTime;\n        uint32 depositInterval;\n    }\n\n    struct GnosisAuctionParameters {\n        uint256 auctionCancelTime;\n        uint256 auctionTime;\n        uint96 minRatioSold;\n        uint256 minBuyAmount;\n        uint256 minFundingThreshold;\n    }\n\n    // ========= STATE VARIABLES ========= //\n\n    /// Tokens\n    IERC20 public ohm;\n\n    /// Contract Dependencies\n    ITreasury public treasury;\n\n    /// Market Creation Systems\n    IBondSDA public fixedExpiryAuctioneer;\n    IBondTeller public fixedExpiryTeller;\n    IEasyAuction public gnosisEasyAuction;\n\n    /// Market parameters\n    BondProtocolParameters public bondProtocolParameters;\n    GnosisAuctionParameters public gnosisAuctionParameters;\n\n    constructor(\n        address ohm_,\n        address treasury_,\n        address feAuctioneer_,\n        address feTeller_,\n        address gnosisAuction_,\n        address authority_\n    ) OlympusAccessControlled(IOlympusAuthority(authority_)) {\n        ohm = IERC20(ohm_);\n        treasury = ITreasury(treasury_);\n        fixedExpiryAuctioneer = IBondSDA(feAuctioneer_);\n        fixedExpiryTeller = IBondTeller(feTeller_);\n        gnosisEasyAuction = IEasyAuction(gnosisAuction_);\n    }\n\n    // ========= MARKET CREATION ========= //\n    function createBondProtocolMarket(uint256 capacity_, uint256 bondTerm_) external onlyPolicy returns (uint256) {\n        _topUpOhm(capacity_);\n\n        /// Encodes the information needed for creating a bond market on Bond Protocol\n        bytes memory createMarketParams = abi.encode(\n            ohm, // payoutToken\n            ohm, // quoteToken\n            address(0), // callbackAddress\n            false, // capacityInQuote\n            capacity_, // capacity\n            bondProtocolParameters.initialPrice, // formattedInitialPrice\n            bondProtocolParameters.minPrice, // formattedMinimumPrice\n            bondProtocolParameters.debtBuffer, // debtBuffer\n            uint48(block.timestamp + bondTerm_), // vesting\n            uint48(block.timestamp + bondProtocolParameters.auctionTime), // conclusion\n            bondProtocolParameters.depositInterval, // depositInterval\n            int8(0) // scaleAdjustment\n        );\n\n        ohm.approve(address(fixedExpiryTeller), capacity_);\n        uint256 marketId = fixedExpiryAuctioneer.createMarket(createMarketParams);\n\n        return marketId;\n    }\n\n    function createGnosisAuction(uint96 capacity_, uint256 bondTerm_) external onlyPolicy returns (uint256) {\n        _topUpOhm(capacity_);\n\n        uint48 expiry = uint48(block.timestamp + bondTerm_);\n\n        /// Create bond token\n        ohm.approve(address(fixedExpiryTeller), capacity_);\n        fixedExpiryTeller.deploy(ohm, expiry);\n        (IERC20 bondToken, ) = fixedExpiryTeller.create(ohm, expiry, capacity_);\n\n        /// Launch Gnosis Auction\n        bondToken.approve(address(gnosisEasyAuction), capacity_);\n        uint256 auctionId = gnosisEasyAuction.initiateAuction(\n            bondToken, // auctioningToken\n            ohm, // biddingToken\n            block.timestamp + gnosisAuctionParameters.auctionCancelTime, // last order cancellation time\n            block.timestamp + gnosisAuctionParameters.auctionTime, // auction end time\n            capacity_, // auctioned amount\n            capacity_ / gnosisAuctionParameters.minRatioSold, // minimum tokens bought for auction to be valid\n            gnosisAuctionParameters.minBuyAmount, // minimum purchase size of auctioning token\n            gnosisAuctionParameters.minFundingThreshold, // minimum funding threshold\n            false, // is atomic closure allowed\n            address(0), // access manager contract\n            new bytes(0) // access manager contract data\n        );\n\n        return auctionId;\n    }\n\n    // ========= PARAMETER ADJUSTMENT ========= //\n    function setBondProtocolParameters(\n        uint256 initialPrice_,\n        uint256 minPrice_,\n        uint32 debtBuffer_,\n        uint256 auctionTime_,\n        uint32 depositInterval_\n    ) external onlyPolicy {\n        bondProtocolParameters = BondProtocolParameters({\n            initialPrice: initialPrice_,\n            minPrice: minPrice_,\n            debtBuffer: debtBuffer_,\n            auctionTime: auctionTime_,\n            depositInterval: depositInterval_\n        });\n    }\n\n    function setGnosisAuctionParameters(\n        uint256 auctionCancelTime_,\n        uint256 auctionTime_,\n        uint96 minRatioSold_,\n        uint256 minBuyAmount_,\n        uint256 minFundingThreshold_\n    ) external onlyPolicy {\n        gnosisAuctionParameters = GnosisAuctionParameters({\n            auctionCancelTime: auctionCancelTime_,\n            auctionTime: auctionTime_,\n            minRatioSold: minRatioSold_,\n            minBuyAmount: minBuyAmount_,\n            minFundingThreshold: minFundingThreshold_\n        });\n    }\n\n    // ========= INTERNAL FUNCTIONS ========= //\n    function _topUpOhm(uint256 amountToDeploy_) internal {\n        uint256 ohmBalance = ohm.balanceOf(address(this));\n\n        if (amountToDeploy_ > ohmBalance) {\n            uint256 amountToMint = amountToDeploy_ - ohmBalance;\n            treasury.mint(address(this), amountToMint);\n        }\n    }\n\n    // ========= EMERGENCY FUNCTIONS ========= //\n    function emergencyWithdraw(uint256 amount) external onlyPolicy {\n        ohm.transfer(address(treasury), amount);\n    }\n}\n"
    },
    "contracts/peripheral/OTCEscrow.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport {IERC20} from \"../interfaces/IERC20.sol\";\nimport {SafeERC20} from \"../libraries/SafeERC20.sol\";\n\nerror OTCEscrow_UnapprovedUser();\nerror OTCEscrow_NotOlympus();\nerror OTCEscrow_TradeInProgress();\n\n/// @title  Olympus OTC Escrow\n/// @notice Olympus OTC Escrow Contract\n/// @dev    The Olympus OTC Escrow contract is a reusable contract for handling OTC trades\n///         with other crypto institutions\ncontract OTCEscrow {\n    using SafeERC20 for IERC20;\n\n    /* ========== STATE VARIABLES ========== */\n\n    /// Involved Parties\n    address public olympus;\n    address public tradePartner;\n\n    /// OTC Tokens\n    address public olympusToken;\n    address public externalToken;\n\n    /// Token Amounts\n    uint256 public olympusAmount;\n    uint256 public externalAmount;\n\n    constructor(\n        address olympus_,\n        address tradePartner_,\n        address olympusToken_,\n        address externalToken_,\n        uint256 olympusAmount_,\n        uint256 externalAmount_\n    ) {\n        olympus = olympus_;\n        tradePartner = tradePartner_;\n\n        olympusToken = olympusToken_;\n        externalToken = externalToken_;\n\n        olympusAmount = olympusAmount_;\n        externalAmount = externalAmount_;\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyApprovedParties() {\n        if (msg.sender != olympus && msg.sender != tradePartner) revert OTCEscrow_UnapprovedUser();\n        _;\n    }\n\n    modifier onlyOlympus() {\n        if (msg.sender != olympus) revert OTCEscrow_NotOlympus();\n        _;\n    }\n\n    modifier tradeInactive() {\n        uint256 olympusTokenBalance = IERC20(olympusToken).balanceOf(address(this));\n        if (olympusTokenBalance != 0) revert OTCEscrow_TradeInProgress();\n        _;\n    }\n\n    /* ========== OTC TRADE FUNCTIONS ========== */\n\n    /// @notice Exchanges tokens by transferring tokens from the trade partner to Olympus and\n    ///         Olympus's tokens that were escrowed in the contract to the trade partner\n    /// @notice Access restricted to Olympus and the trade partner\n    function swap() external onlyApprovedParties {\n        IERC20(externalToken).safeTransferFrom(tradePartner, olympus, externalAmount);\n        IERC20(olympusToken).safeTransfer(tradePartner, olympusAmount);\n    }\n\n    /// @notice Cancels an OTC trade and returns Olympus's escrowed tokens to the multisig\n    /// @notice Access restricted to Olympus\n    function revoke() external onlyOlympus {\n        uint256 olympusTokenBalance = IERC20(olympusToken).balanceOf(address(this));\n        IERC20(olympusToken).safeTransfer(olympus, olympusTokenBalance);\n    }\n\n    /// @notice Allows removal of trade partner tokens if they were accidentally sent to the\n    ///         contract rather than exchanged through the swap function\n    /// @notice Access restricted to Olympus and the trade partner\n    function revokeReceivedToken() external onlyApprovedParties {\n        uint256 externalTokenBalance = IERC20(externalToken).balanceOf(address(this));\n        IERC20(externalToken).safeTransfer(tradePartner, externalTokenBalance);\n    }\n\n    /* ========== MANAGEMENT FUNCTIONS ========== */\n\n    /// @notice Sets the trade parameters for a new OTC exchange if no trade is in progress\n    /// @notice Access restricted to Olympus\n    function newTrade(\n        address tradePartner_,\n        address olympusToken_,\n        address externalToken_,\n        uint256 olympusAmount_,\n        uint256 externalAmount_\n    ) external onlyOlympus tradeInactive {\n        tradePartner = tradePartner_;\n\n        olympusToken = olympusToken_;\n        externalToken = externalToken_;\n\n        olympusAmount = olympusAmount_;\n        externalAmount = externalAmount_;\n    }\n}\n"
    },
    "contracts/peripheral/PriceConverterOracleWrapper.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport {AggregatorV3Interface} from \"../interfaces/IAggregatorV3.sol\";\n\n/**\n    @title Oracle wrapper\n    @notice Oracle wrapper that uses two oracles to return price in a differen denomination\n */\ncontract PriceConverterOracleWrapper is AggregatorV3Interface {\n    AggregatorV3Interface public immutable basePriceOracle;\n    AggregatorV3Interface public immutable quotePriceOracle;\n    uint8 public immutable override decimals;\n    string public constant override description =\n        \"Oracle wrapper that uses two oracles to return price in a different denomination\";\n    uint256 public constant override version = 0;\n\n    constructor(\n        address _basePriceOracleAddress,\n        address _quotePriceOracleAddress,\n        uint8 decimals_\n    ) {\n        basePriceOracle = AggregatorV3Interface(_basePriceOracleAddress);\n        quotePriceOracle = AggregatorV3Interface(_quotePriceOracleAddress);\n        decimals = decimals_;\n    }\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        (, int256 basePrice, uint256 baseStartedAt, uint256 baseUpdatedAt, ) = AggregatorV3Interface(basePriceOracle)\n            .latestRoundData();\n        uint8 baseDecimals = AggregatorV3Interface(basePriceOracle).decimals();\n\n        (, int256 quotePrice, uint256 quoteStartedAt, uint256 quoteUpdatedAt, ) = AggregatorV3Interface(\n            quotePriceOracle\n        ).latestRoundData();\n        uint8 quoteDecimals = AggregatorV3Interface(quotePriceOracle).decimals();\n\n        int256 unscaledAnswer = (basePrice * int256(10**uint256(decimals)) * int256(10**uint256(quoteDecimals))) /\n            quotePrice;\n        answer = _adjustDecimals(unscaledAnswer, baseDecimals);\n\n        startedAt = baseStartedAt > quoteStartedAt ? baseStartedAt : quoteStartedAt;\n        updatedAt = baseUpdatedAt > quoteUpdatedAt ? baseUpdatedAt : quoteUpdatedAt;\n    }\n\n    function getRoundData(uint80 _roundId)\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {}\n\n    function _adjustDecimals(int256 _unscaledAnswer, uint8 _baseDecimals) internal pure returns (int256) {\n        return _unscaledAnswer / int256(10**uint256(_baseDecimals));\n    }\n}\n"
    },
    "contracts/peripheral/YieldDirector.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"../interfaces/IERC20.sol\";\nimport {IsOHM} from \"../interfaces/IsOHM.sol\";\nimport {IStaking} from \"../interfaces/IStaking.sol\";\nimport {IYieldDirector} from \"../interfaces/IYieldDirector.sol\";\nimport {SafeERC20} from \"../libraries/SafeERC20.sol\";\nimport {YieldSplitter} from \"../types/YieldSplitter.sol\";\n\n/**\n    @title  YieldDirector (codename Tyche) \n    @notice This contract allows donors to deposit their gOHM and donate their rebases\n            to any address. Donors will be able to withdraw the sOHM equivalent of their principal\n            gOHM at any time. Donation recipients can also redeem accrued rebases at any time.\n    @dev    Any functions dealing with initial deposits will take an address (because no ID has been\n            assigned). After a user has deposited, all functions dealing with deposits (like\n            withdraw or redeem functions) will take the ID of the deposit. All functions that return\n            aggregated data grouped by user will take an address (iterates across all relevant IDs).\n */\ncontract YieldDirector is IYieldDirector, YieldSplitter {\n    using SafeERC20 for IERC20;\n\n    error YieldDirector_InvalidAddress();\n    error YieldDirector_InvalidDeposit();\n    error YieldDirector_InvalidUpdate();\n    error YieldDirector_InvalidWithdrawal();\n    error YieldDirector_NotYourYield();\n    error YieldDirector_NoDeposits();\n    error YieldDirector_WithdrawalsDisabled();\n    error YieldDirector_RedeemsDisabled();\n\n    address public immutable sOHM;\n    address public immutable gOHM;\n    IStaking public immutable staking;\n\n    mapping(address => uint256[]) public recipientIds; // address -> array of deposit id's donating yield to the user\n    mapping(uint256 => address) public recipientLookup; // depositId -> recipient\n\n    bool public depositDisabled;\n    bool public withdrawDisabled;\n    bool public redeemDisabled;\n\n    event Deposited(address indexed donor_, address indexed recipient_, uint256 amount_);\n    event Withdrawn(address indexed donor_, address indexed recipient_, uint256 amount_);\n    event AllWithdrawn(address indexed donor_, uint256 indexed amount_);\n    event Donated(address indexed donor_, address indexed recipient_, uint256 amount_);\n    event Redeemed(address indexed recipient_, uint256 amount_);\n    event EmergencyShutdown(bool active_);\n\n    constructor(\n        address sOhm_,\n        address gOhm_,\n        address staking_,\n        address authority_\n    ) YieldSplitter(sOhm_, authority_) {\n        if (sOhm_ == address(0) || gOhm_ == address(0) || staking_ == address(0) || authority_ == address(0))\n            revert YieldDirector_InvalidAddress();\n\n        sOHM = sOhm_;\n        gOHM = gOhm_;\n        staking = IStaking(staking_);\n\n        IERC20(sOHM).safeApprove(address(staking), type(uint256).max);\n    }\n\n    /************************\n     * Modifiers\n     ************************/\n    function isInvalidDeposit(uint256 amount_, address recipient_) internal view returns (bool) {\n        return depositDisabled || amount_ == 0 || recipient_ == address(0);\n    }\n\n    function isInvalidUpdate(uint256 depositId_, uint256 amount_) internal view returns (bool) {\n        return depositDisabled || amount_ == 0 || depositInfo[depositId_].depositor == address(0);\n    }\n\n    function isInvalidWithdrawal(uint256 amount_) internal view returns (bool) {\n        return withdrawDisabled || amount_ == 0;\n    }\n\n    /************************\n     * Donor Functions\n     ************************/\n\n    /**\n        @notice Deposit gOHM, records sender address and assign rebases to recipient\n        @param amount_ Amount of gOHM debt issued from donor to recipient\n        @param recipient_ Address to direct staking yield and vault shares to\n    */\n    function deposit(uint256 amount_, address recipient_) external override returns (uint256 depositId) {\n        depositId = _createDeposit(amount_, recipient_);\n\n        IERC20(gOHM).safeTransferFrom(msg.sender, address(this), amount_);\n    }\n\n    /**\n        @notice Deposit sOHM, wrap to gOHM, and records sender address and assign rebases to recipeint\n        @param amount_ Amount of sOHM debt issued from donor to recipient\n        @param recipient_ Address to direct staking yield and vault shares to\n    */\n    function depositSohm(uint256 amount_, address recipient_) external override returns (uint256 depositId) {\n        uint256 gohmAmount = _toAgnostic(amount_);\n        depositId = _createDeposit(gohmAmount, recipient_);\n\n        IERC20(sOHM).safeTransferFrom(msg.sender, address(this), amount_);\n        staking.wrap(address(this), amount_);\n    }\n\n    /**\n        @notice Deposit additional gOHM, and update deposit record\n        @param depositId_ Deposit ID to direct additional gOHM to\n        @param amount_ Amount of new gOHM debt issued from donor to recipient\n    */\n    function addToDeposit(uint256 depositId_, uint256 amount_) external override {\n        _increaseDeposit(depositId_, amount_);\n\n        IERC20(gOHM).safeTransferFrom(msg.sender, address(this), amount_);\n    }\n\n    /**\n        @notice Deposit additional sOHM, wrap to gOHM, and update deposit record\n        @param depositId_ Deposit ID to direct additional gOHM to\n        @param amount_ Amount of new sOHM debt issued from donor to recipient\n    */\n    function addToSohmDeposit(uint256 depositId_, uint256 amount_) external override {\n        uint256 gohmAmount = _toAgnostic(amount_);\n        _increaseDeposit(depositId_, gohmAmount);\n\n        IERC20(sOHM).safeTransferFrom(msg.sender, address(this), amount_);\n        staking.wrap(address(this), amount_);\n    }\n\n    /**\n        @notice Withdraw donor's gOHM from vault\n        @param depositId_ Deposit ID to remove gOHM deposit from\n        @param amount_ Amount of gOHM deposit to remove and return to donor\n    */\n    function withdrawPrincipal(uint256 depositId_, uint256 amount_) external override {\n        uint256 amountWithdrawn = _withdraw(depositId_, amount_);\n\n        IERC20(gOHM).safeTransfer(msg.sender, amountWithdrawn);\n    }\n\n    /**\n        @notice Withdraw donor's gOHM from vault, and return it as sOHM\n        @param depositId_ Deposit ID to remove gOHM debt from\n        @param amount_ Amount of gOHM debt to remove and return to donor as sOHM\n    */\n    function withdrawPrincipalAsSohm(uint256 depositId_, uint256 amount_) external override {\n        uint256 amountWithdrawn = _withdraw(depositId_, amount_);\n\n        staking.unwrap(msg.sender, amountWithdrawn);\n    }\n\n    /**\n        @notice Withdraw all gOHM from all donor positions\n    */\n    function withdrawAll() external override {\n        if (withdrawDisabled) revert YieldDirector_WithdrawalsDisabled();\n\n        uint256[] memory depositIds = depositorIds[msg.sender];\n\n        uint256 depositsLength = depositIds.length;\n        if (depositsLength == 0) revert YieldDirector_NoDeposits();\n\n        uint256 principalTotal = 0;\n\n        for (uint256 index = 0; index < depositsLength; ++index) {\n            DepositInfo storage currDeposit = depositInfo[depositIds[index]];\n\n            principalTotal += currDeposit.principalAmount;\n\n            _withdrawAllPrincipal(depositIds[index], msg.sender);\n        }\n\n        uint256 agnosticAmount = _toAgnostic(principalTotal);\n\n        emit AllWithdrawn(msg.sender, agnosticAmount);\n\n        IERC20(gOHM).safeTransfer(msg.sender, agnosticAmount);\n    }\n\n    /************************\n     * View Functions\n     ************************/\n\n    /**\n        @notice Get deposited gOHM amounts for specific recipient (updated to current index\n                based on sOHM equivalent amount deposit)\n        @param donor_ Address of user donating yield\n        @param recipient_ Address of user receiving donated yield\n    */\n    function depositsTo(address donor_, address recipient_) external view override returns (uint256) {\n        uint256[] memory depositIds = depositorIds[donor_];\n\n        uint256 totalPrincipalDeposits;\n        for (uint256 index = 0; index < depositIds.length; ++index) {\n            uint256 id = depositIds[index];\n\n            if (recipientLookup[id] == recipient_) {\n                totalPrincipalDeposits += depositInfo[id].principalAmount;\n            }\n        }\n\n        return _toAgnostic(totalPrincipalDeposits);\n    }\n\n    /**\n        @notice Return total amount of donor's gOHM deposited (updated to current index based\n                on sOHM equivalent amount deposited)\n        @param donor_ Address of user donating yield\n    */\n    function totalDeposits(address donor_) external view override returns (uint256) {\n        uint256[] memory depositIds = depositorIds[donor_];\n        uint256 principalTotal = 0;\n\n        for (uint256 index = 0; index < depositIds.length; ++index) {\n            principalTotal += depositInfo[depositIds[index]].principalAmount;\n        }\n\n        return _toAgnostic(principalTotal);\n    }\n\n    /**\n        @notice Return arrays of donor's recipients and deposit amounts (gOHM value based on\n                sOHM equivalent deposit), matched by index\n        @param donor_ Address of user donating yield\n    */\n    function getAllDeposits(address donor_) external view override returns (address[] memory, uint256[] memory) {\n        uint256[] memory depositIds = depositorIds[donor_];\n\n        uint256 len = depositIds.length == 0 ? 1 : depositIds.length;\n\n        address[] memory addresses = new address[](len);\n        uint256[] memory agnosticDeposits = new uint256[](len);\n\n        if (depositIds.length == 0) {\n            addresses[0] = address(0);\n            agnosticDeposits[0] = 0;\n        } else {\n            for (uint256 index = 0; index < len; ++index) {\n                addresses[index] = recipientLookup[depositIds[index]];\n                agnosticDeposits[index] = _toAgnostic(depositInfo[depositIds[index]].principalAmount);\n            }\n        }\n\n        return (addresses, agnosticDeposits);\n    }\n\n    /**\n        @notice Return total amount of gOHM donated to recipient since last full redemption\n        @param donor_ Address of user donating yield\n        @param recipient_ Address of user recieiving donated yield\n    */\n    function donatedTo(address donor_, address recipient_) external view override returns (uint256) {\n        uint256[] memory depositIds = depositorIds[donor_];\n\n        uint256 totalRedeemable;\n        for (uint256 index = 0; index < depositIds.length; ++index) {\n            if (recipientLookup[depositIds[index]] == recipient_) {\n                totalRedeemable += redeemableBalance(depositIds[index]);\n            }\n        }\n\n        return totalRedeemable;\n    }\n\n    /**\n        @notice Return total amount of gOHM donated from donor since last full redemption\n        @param donor_ Address of user donating yield\n    */\n    function totalDonated(address donor_) external view override returns (uint256) {\n        uint256[] memory depositIds = depositorIds[donor_];\n\n        uint256 principalTotal = 0;\n        uint256 agnosticTotal = 0;\n\n        for (uint256 index = 0; index < depositIds.length; ++index) {\n            DepositInfo storage currDeposit = depositInfo[depositIds[index]];\n\n            principalTotal += currDeposit.principalAmount;\n            agnosticTotal += currDeposit.agnosticAmount;\n        }\n\n        return _getOutstandingYield(principalTotal, agnosticTotal);\n    }\n\n    /************************\n     * Recipient Functions\n     ************************/\n\n    /**\n        @notice Get redeemable gOHM balance of a specific deposit\n        @param depositId_ Deposit ID for this donation\n    */\n    function redeemableBalance(uint256 depositId_) public view override returns (uint256) {\n        DepositInfo storage currDeposit = depositInfo[depositId_];\n\n        return _getOutstandingYield(currDeposit.principalAmount, currDeposit.agnosticAmount);\n    }\n\n    /**\n        @notice Get redeemable gOHM balance of a recipient address\n        @param recipient_ Address of user receiving donated yield\n     */\n    function totalRedeemableBalance(address recipient_) external view override returns (uint256) {\n        uint256[] memory receiptIds = recipientIds[recipient_];\n\n        uint256 agnosticRedeemable = 0;\n\n        for (uint256 index = 0; index < receiptIds.length; ++index) {\n            agnosticRedeemable += redeemableBalance(receiptIds[index]);\n        }\n\n        return agnosticRedeemable;\n    }\n\n    /**\n        @notice Getter function for a recipient's list of IDs. This is needed for the frontend\n                as public state variables that map to arrays only return one element at a time\n                rather than the full array\n    */\n    function getRecipientIds(address recipient_) external view override returns (uint256[] memory) {\n        return recipientIds[recipient_];\n    }\n\n    /**\n        @notice Redeem recipient's donated amount of sOHM at current index from one donor as gOHM\n        @param depositId_ Deposit ID for this donation\n    */\n    function redeemYield(uint256 depositId_) external override {\n        uint256 amountRedeemed = _redeem(depositId_, msg.sender);\n\n        IERC20(gOHM).safeTransfer(msg.sender, amountRedeemed);\n    }\n\n    /**\n        @notice Redeem recipient's donated amount of sOHM at current index\n        @param depositId_ Deposit id for this donation\n    */\n    function redeemYieldAsSohm(uint256 depositId_) external override {\n        uint256 amountRedeemed = _redeem(depositId_, msg.sender);\n\n        staking.unwrap(msg.sender, amountRedeemed);\n    }\n\n    /**\n        @notice Redeem recipient's full donated amount of sOHM at current index as gOHM\n    */\n    function redeemAllYield() external override {\n        uint256 amountRedeemed = _redeemAll(msg.sender);\n\n        IERC20(gOHM).safeTransfer(msg.sender, amountRedeemed);\n    }\n\n    /**\n        @notice Redeem recipient's full donated amount of sOHM at current index as gOHM\n    */\n    function redeemAllYieldAsSohm() external override {\n        uint256 amountRedeemed = _redeemAll(msg.sender);\n\n        staking.unwrap(msg.sender, amountRedeemed);\n    }\n\n    /**\n        @notice Redeems yield from a deposit and sends it to the recipient\n        @param id_ Id of the deposit.\n    */\n    function redeemYieldOnBehalfOf(uint256 id_) external override returns (uint256 amount_) {\n        if (!hasPermissionToRedeem[msg.sender]) revert YieldDirector_NotYourYield();\n\n        address recipient = recipientLookup[id_];\n\n        amount_ = _redeem(id_, recipient);\n\n        IERC20(gOHM).safeTransfer(recipient, amount_);\n    }\n\n    /**\n        @notice Redeems all yield tied to a recipient and sends it to the recipient\n        @param recipient_ recipient address.\n    */\n    function redeemAllYieldOnBehalfOf(address recipient_) external override returns (uint256 amount_) {\n        if (!hasPermissionToRedeem[msg.sender]) revert YieldDirector_NotYourYield();\n\n        amount_ = _redeemAll(recipient_);\n\n        IERC20(gOHM).safeTransfer(recipient_, amount_);\n    }\n\n    /************************\n     * Internal Functions\n     ************************/\n\n    /**\n        @notice Creates a new deposit directing the yield from the deposited gOHM amount\n                to the prescribed recipient\n        @param amount_ Quantity of gOHM deposited redirecting yield to the recipient\n        @param recipient_ The address of the user who will be entitled to claim the donated yield\n    */\n    function _createDeposit(uint256 amount_, address recipient_) internal returns (uint256 depositId) {\n        if (isInvalidDeposit(amount_, recipient_)) revert YieldDirector_InvalidDeposit();\n\n        depositId = _deposit(msg.sender, amount_);\n        recipientIds[recipient_].push(depositId);\n        recipientLookup[depositId] = recipient_;\n\n        emit Deposited(msg.sender, recipient_, amount_);\n    }\n\n    /**\n        @notice Increases the amount of gOHM directing yield to a recipient\n        @param depositId_ The global ID number of the deposit to add the additional deposit to\n        @param amount_ Quantity of new gOHM deposited redirecting yield to the current deposit's recipient\n    */\n    function _increaseDeposit(uint256 depositId_, uint256 amount_) internal {\n        if (isInvalidUpdate(depositId_, amount_)) revert YieldDirector_InvalidUpdate();\n\n        _addToDeposit(depositId_, amount_, msg.sender);\n\n        emit Deposited(msg.sender, recipientLookup[depositId_], amount_);\n    }\n\n    /**\n        @notice Withdraw gOHM deposit from vault\n        @param depositId_ Deposit ID to remove gOHM deposit from\n        @param amount_ Amount of gOHM deposit to remove and return to donor \n    */\n    function _withdraw(uint256 depositId_, uint256 amount_) internal returns (uint256 amountWithdrawn) {\n        if (isInvalidWithdrawal(amount_)) revert YieldDirector_InvalidWithdrawal();\n\n        if (amount_ < _toAgnostic(depositInfo[depositId_].principalAmount)) {\n            _withdrawPrincipal(depositId_, amount_, msg.sender);\n            amountWithdrawn = amount_;\n        } else {\n            amountWithdrawn = _withdrawAllPrincipal(depositId_, msg.sender);\n        }\n\n        emit Withdrawn(msg.sender, recipientLookup[depositId_], amountWithdrawn);\n    }\n\n    /**\n        @notice Redeem available gOHM yield from a specific deposit\n        @param depositId_ Deposit ID to withdraw gOHM yield from\n        @param recipient_ address of recipient\n    */\n    function _redeem(uint256 depositId_, address recipient_) internal returns (uint256 amountRedeemed) {\n        if (redeemDisabled) revert YieldDirector_RedeemsDisabled();\n        if (recipientLookup[depositId_] != recipient_) revert YieldDirector_NotYourYield();\n\n        amountRedeemed = _redeemYield(depositId_);\n\n        if (depositInfo[depositId_].principalAmount == 0) {\n            _closeDeposit(depositId_, depositInfo[depositId_].depositor);\n\n            uint256[] storage receiptIds = recipientIds[recipient_];\n            uint256 idsLength = receiptIds.length;\n\n            for (uint256 i = 0; i < idsLength; ++i) {\n                if (receiptIds[i] == depositId_) {\n                    // Remove id from recipient's ids array\n                    receiptIds[i] = receiptIds[idsLength - 1]; // Delete integer from array by swapping with last element and calling pop()\n                    receiptIds.pop();\n                    break;\n                }\n            }\n\n            delete recipientLookup[depositId_];\n        }\n\n        emit Redeemed(recipient_, amountRedeemed);\n        emit Donated(depositInfo[depositId_].depositor, recipient_, amountRedeemed);\n    }\n\n    /**\n        @notice Redeem all available gOHM yield from the vault\n        @param recipient_ address of recipient\n    */\n    function _redeemAll(address recipient_) internal returns (uint256 amountRedeemed) {\n        if (redeemDisabled) revert YieldDirector_RedeemsDisabled();\n\n        uint256[] storage receiptIds = recipientIds[recipient_];\n\n        // We iterate through the array back to front so that we can delete\n        // elements from the array without changing the locations of any\n        // entries that have not been checked yet\n        for (uint256 index = receiptIds.length; index > 0; index--) {\n            uint256 currIndex = index - 1;\n\n            address currDepositor = depositInfo[receiptIds[currIndex]].depositor;\n            uint256 currRedemption = _redeemYield(receiptIds[currIndex]);\n            amountRedeemed += currRedemption;\n\n            emit Donated(currDepositor, recipient_, currRedemption);\n\n            if (depositInfo[receiptIds[currIndex]].principalAmount == 0) {\n                _closeDeposit(receiptIds[currIndex], currDepositor);\n\n                if (currIndex != receiptIds.length - 1) {\n                    receiptIds[currIndex] = receiptIds[receiptIds.length - 1]; // Delete integer from array by swapping with last element and calling pop()\n                }\n\n                delete recipientLookup[receiptIds[currIndex]];\n                receiptIds.pop();\n            }\n        }\n\n        emit Redeemed(recipient_, amountRedeemed);\n    }\n\n    /************************\n     * Emergency Functions\n     ************************/\n\n    function emergencyShutdown(bool active_) external onlyGovernor {\n        depositDisabled = active_;\n        withdrawDisabled = active_;\n        redeemDisabled = active_;\n        emit EmergencyShutdown(active_);\n    }\n\n    function disableDeposits(bool active_) external onlyGovernor {\n        depositDisabled = active_;\n    }\n\n    function disableWithdrawals(bool active_) external onlyGovernor {\n        withdrawDisabled = active_;\n    }\n\n    function disableRedeems(bool active_) external onlyGovernor {\n        redeemDisabled = active_;\n    }\n}\n"
    },
    "contracts/peripheral/YieldStreamer.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"../interfaces/IERC20.sol\";\nimport {IgOHM} from \"../interfaces/IgOHM.sol\";\nimport {SafeERC20} from \"../libraries/SafeERC20.sol\";\nimport {IYieldStreamer} from \"../interfaces/IYieldStreamer.sol\";\nimport {IUniswapV2Router} from \"../interfaces/IUniswapV2Router.sol\";\nimport {IStaking} from \"../interfaces/IStaking.sol\";\nimport {YieldSplitter} from \"../types/YieldSplitter.sol\";\nimport {AggregatorV3Interface} from \"../interfaces/IAggregatorV3.sol\";\n\nerror YieldStreamer_DepositDisabled();\nerror YieldStreamer_WithdrawDisabled();\nerror YieldStreamer_UpkeepDisabled();\nerror YieldStreamer_UnauthorisedAction();\nerror YieldStreamer_MinTokenThresholdTooLow();\nerror YieldStreamer_InvalidAmount();\n\n/**\n    @title YieldStreamer\n    @notice This contract allows users to deposit their gOhm and have their yield\n            converted into a streamToken(normally DAI) and sent to their address every interval.\n */\ncontract YieldStreamer is IYieldStreamer, YieldSplitter {\n    using SafeERC20 for IERC20;\n\n    address public immutable OHM;\n    address public immutable gOHM;\n    address public immutable streamToken; // Default is DAI but can be any token\n    IUniswapV2Router public immutable sushiRouter;\n    address[] public sushiRouterPath = new address[](2);\n    IStaking public immutable staking;\n    AggregatorV3Interface public immutable priceConverterOracleWrapper;\n\n    bool public depositDisabled;\n    bool public withdrawDisabled;\n    bool public upkeepDisabled;\n\n    uint256 public maxSwapSlippagePercent; // 6 decimals 1e6 is 100%\n    uint256 public feeToDaoPercent; // 6 decimals 1e6 is 100%\n    uint256 private constant sixDecimalMaxNumber = 1e6;\n    uint256 public minimumTokenThreshold;\n\n    struct RecipientInfo {\n        address recipientAddress;\n        uint128 lastUpkeepTimestamp;\n        uint128 paymentInterval; // Time before yield is able to be swapped to stream tokens\n        uint128 unclaimedStreamTokens;\n        uint128 userMinimumAmountThreshold;\n    }\n\n    mapping(uint256 => RecipientInfo) public recipientInfo; // depositId -> RecipientInfo\n    mapping(address => uint256[]) public recipientIds; // address -> Array of the deposit id's user is recipient of\n    uint256[] public activeDepositIds; // All deposit ids that are not empty or deleted\n\n    event Deposited(address indexed depositor_, uint256 amount_);\n    event Withdrawn(address indexed depositor_, uint256 amount_);\n    event UpkeepComplete(uint256 indexed timestamp);\n    event EmergencyShutdown(bool active_);\n\n    /**\n        @notice Constructor\n        @param gOHM_ Address of gOHM.\n        @param sOHM_ Address of sOHM.\n        @param OHM_ Address of OHM.\n        @param streamToken_ Address of the token the ohm will be swapped to.\n        @param sushiRouter_ Address of sushiswap router.\n        @param staking_ Address of sOHM staking contract.\n        @param authority_ Address of Olympus authority contract.\n        @param maxSwapSlippagePercent_ Maximum acceptable slippage when swapping OHM to streamTokens as percentage 6 decimals.\n        @param feeToDaoPercent_ How much of yield goes to DAO before swapping to streamTokens as percentage 6 decimals.\n        @param minimumTokenThreshold_ Minimum a user can set threshold for amount of tokens accumulated as yield \n                                    before sending to recipient's wallet.\n    */\n    constructor(\n        address gOHM_,\n        address sOHM_,\n        address OHM_,\n        address streamToken_,\n        address sushiRouter_,\n        address staking_,\n        address authority_,\n        address priceConverterOracleWrapper_,\n        uint128 maxSwapSlippagePercent_,\n        uint128 feeToDaoPercent_,\n        uint256 minimumTokenThreshold_\n    ) YieldSplitter(sOHM_, authority_) {\n        gOHM = gOHM_;\n        OHM = OHM_;\n        streamToken = streamToken_;\n        sushiRouter = IUniswapV2Router(sushiRouter_);\n        staking = IStaking(staking_);\n        priceConverterOracleWrapper = AggregatorV3Interface(priceConverterOracleWrapper_);\n        sushiRouterPath[0] = OHM;\n        sushiRouterPath[1] = streamToken;\n        maxSwapSlippagePercent = maxSwapSlippagePercent_;\n        feeToDaoPercent = feeToDaoPercent_;\n        minimumTokenThreshold = minimumTokenThreshold_;\n\n        IERC20(gOHM).approve(address(staking), type(uint256).max);\n        IERC20(OHM).approve(address(sushiRouter), type(uint256).max);\n    }\n\n    /**\n        @notice Deposit gOHM, creates a deposit in the active deposit pool to be unkept.\n        @param amount_ Amount of gOHM.\n        @param recipient_ Address to direct staking yield and vault shares to.\n        @param paymentInterval_ How much time must elapse before yield is able to be swapped for stream tokens.\n        @param userMinimumAmountThreshold_ Minimum amount of stream tokens a user must have during upkeep for it to be sent to their wallet.\n    */\n    function deposit(\n        uint256 amount_,\n        address recipient_,\n        uint128 paymentInterval_,\n        uint128 userMinimumAmountThreshold_\n    ) external override {\n        if (depositDisabled) revert YieldStreamer_DepositDisabled();\n        if (amount_ == 0) revert YieldStreamer_InvalidAmount();\n        if (userMinimumAmountThreshold_ < minimumTokenThreshold) revert YieldStreamer_MinTokenThresholdTooLow();\n\n        uint256 depositId = _deposit(msg.sender, amount_);\n\n        recipientInfo[depositId] = RecipientInfo({\n            recipientAddress: recipient_,\n            lastUpkeepTimestamp: uint128(block.timestamp),\n            paymentInterval: paymentInterval_,\n            unclaimedStreamTokens: 0,\n            userMinimumAmountThreshold: userMinimumAmountThreshold_\n        });\n\n        activeDepositIds.push(depositId);\n        recipientIds[recipient_].push(depositId);\n\n        IERC20(gOHM).safeTransferFrom(msg.sender, address(this), amount_);\n\n        emit Deposited(msg.sender, amount_);\n    }\n\n    /**\n        @notice Add more gOHM to your principal deposit.\n        @param id_ Id of the deposit.\n        @param amount_ Amount of gOHM to add.\n    */\n    function addToDeposit(uint256 id_, uint256 amount_) external override {\n        if (depositDisabled) revert YieldStreamer_DepositDisabled();\n\n        _addToDeposit(id_, amount_, msg.sender);\n\n        IERC20(gOHM).safeTransferFrom(msg.sender, address(this), amount_);\n\n        emit Deposited(msg.sender, amount_);\n    }\n\n    /**\n        @notice Withdraw part or all of your principal amount deposited.\n        @dev If withdrawing all your principal, all accumulated yield will be sent to recipient \n             and deposit will be closed.\n        @param id_ Id of the deposit.\n        @param amount_ Amount of gOHM to withdraw.\n    */\n    function withdrawPrincipal(uint256 id_, uint256 amount_) external override {\n        if (withdrawDisabled) revert YieldStreamer_WithdrawDisabled();\n\n        if (amount_ < IgOHM(gOHM).balanceTo(depositInfo[id_].principalAmount)) {\n            _withdrawPrincipal(id_, amount_, msg.sender);\n            IERC20(gOHM).safeTransfer(msg.sender, amount_);\n        } else {\n            address recipient = recipientInfo[id_].recipientAddress;\n            uint256 unclaimedStreamTokens = recipientInfo[id_].unclaimedStreamTokens;\n            (uint256 principal, uint256 totalGOHM) = _closeDeposit(id_, msg.sender);\n            delete recipientInfo[id_];\n\n            uint256 depositLength = activeDepositIds.length;\n            for (uint256 i = 0; i < depositLength; i++) {\n                // Delete integer from array by swapping with last element and calling pop()\n                if (activeDepositIds[i] == id_) {\n                    activeDepositIds[i] = activeDepositIds[depositLength - 1];\n                    activeDepositIds.pop();\n                    break;\n                }\n            }\n\n            uint256[] storage recipientIdsArray = recipientIds[recipient];\n            uint256 recipientLength = recipientIdsArray.length;\n            for (uint256 i = 0; i < recipientLength; i++) {\n                // Delete integer from array by swapping with last element and calling pop()\n                if (recipientIdsArray[i] == id_) {\n                    recipientIdsArray[i] = recipientIdsArray[recipientLength - 1];\n                    recipientIdsArray.pop();\n                    break;\n                }\n            }\n\n            IERC20(gOHM).safeTransfer(msg.sender, principal);\n            IERC20(gOHM).safeTransfer(recipient, totalGOHM - principal);\n            if (unclaimedStreamTokens != 0) {\n                IERC20(streamToken).safeTransfer(recipient, unclaimedStreamTokens);\n            }\n        }\n\n        emit Withdrawn(msg.sender, amount_);\n    }\n\n    /**\n        @notice Withdraw excess yield from your deposit in gOHM.\n        @dev  Use withdrawYieldInStreamTokens() to withdraw yield in stream tokens.\n        @param id_ Id of the deposit.\n    */\n    function withdrawYield(uint256 id_) external override {\n        if (withdrawDisabled) revert YieldStreamer_WithdrawDisabled();\n        if (recipientInfo[id_].recipientAddress != msg.sender) revert YieldStreamer_UnauthorisedAction();\n\n        uint256 yield = _redeemYield(id_);\n        recipientInfo[id_].lastUpkeepTimestamp = uint128(block.timestamp);\n\n        IERC20(gOHM).safeTransfer(msg.sender, yield);\n    }\n\n    /**\n        @notice Withdraw all excess yield from your all deposits you are the recipient of in gOHM.\n        @dev  Use withdrawYieldInStreamTokens() to withdraw yield in stream tokens.\n    */\n    function withdrawAllYield() external override {\n        if (withdrawDisabled) revert YieldStreamer_WithdrawDisabled();\n\n        uint256 total;\n        uint256[] memory receiptIds = recipientIds[msg.sender];\n\n        for (uint256 i = 0; i < receiptIds.length; i++) {\n            total += _redeemYield(receiptIds[i]);\n            recipientInfo[receiptIds[i]].lastUpkeepTimestamp = uint128(block.timestamp);\n        }\n\n        IERC20(gOHM).safeTransfer(msg.sender, total);\n    }\n\n    /**\n        @notice harvest all your unclaimed stream tokens\n        @param id_ Id of the deposit\n    */\n    function harvestStreamTokens(uint256 id_) external override {\n        if (withdrawDisabled) revert YieldStreamer_WithdrawDisabled();\n        if (recipientInfo[id_].recipientAddress != msg.sender) revert YieldStreamer_UnauthorisedAction();\n\n        uint256 streamTokensToSend = recipientInfo[id_].unclaimedStreamTokens;\n        recipientInfo[id_].unclaimedStreamTokens = 0;\n        IERC20(streamToken).safeTransfer(msg.sender, streamTokensToSend);\n    }\n\n    /**\n        @notice Redeems yield from a deposit and sends it to the recipient\n        @param id_ Id of the deposit.\n    */\n    function redeemYieldOnBehalfOf(uint256 id_) external override returns (uint256 amount_) {\n        if (withdrawDisabled) revert YieldStreamer_WithdrawDisabled();\n        if (!hasPermissionToRedeem[msg.sender]) revert YieldStreamer_UnauthorisedAction();\n\n        amount_ = _redeemYield(id_);\n        recipientInfo[id_].lastUpkeepTimestamp = uint128(block.timestamp);\n\n        IERC20(gOHM).safeTransfer(recipientInfo[id_].recipientAddress, amount_);\n    }\n\n    /**\n        @notice Redeems all yield tied to a recipient and sends it to the recipient\n        @param recipient_ recipient address.\n    */\n    function redeemAllYieldOnBehalfOf(address recipient_) external override returns (uint256 amount_) {\n        if (withdrawDisabled) revert YieldStreamer_WithdrawDisabled();\n        if (!hasPermissionToRedeem[msg.sender]) revert YieldStreamer_UnauthorisedAction();\n\n        uint256[] memory receiptIds = recipientIds[recipient_];\n\n        for (uint256 i = 0; i < receiptIds.length; i++) {\n            amount_ += _redeemYield(receiptIds[i]);\n            recipientInfo[receiptIds[i]].lastUpkeepTimestamp = uint128(block.timestamp);\n        }\n\n        IERC20(gOHM).safeTransfer(recipient_, amount_);\n    }\n\n    /**\n        @notice User updates the minimum amount of streamTokens threshold before upkeep sends streamTokens to recipients wallet\n        @param id_ Id of the deposit\n        @param threshold_ amount of streamTokens\n    */\n    function updateUserMinThreshold(uint256 id_, uint128 threshold_) external override {\n        if (threshold_ < minimumTokenThreshold) revert YieldStreamer_MinTokenThresholdTooLow();\n        if (depositInfo[id_].depositor != msg.sender) revert YieldStreamer_UnauthorisedAction();\n\n        recipientInfo[id_].userMinimumAmountThreshold = threshold_;\n    }\n\n    /**\n        @notice User updates the minimum amount of time passes before the deposit is included in upkeep\n        @param id_ Id of the deposit\n        @param paymentInterval_ amount of time in seconds\n    */\n    function updatePaymentInterval(uint256 id_, uint128 paymentInterval_) external override {\n        if (depositInfo[id_].depositor != msg.sender) revert YieldStreamer_UnauthorisedAction();\n\n        recipientInfo[id_].paymentInterval = paymentInterval_;\n    }\n\n    /**\n        @notice Upkeeps all deposits if they are eligible.\n                Upkeep consists of converting all eligible deposits yield from gOhm into streamToken(usually DAI).\n                Sends the yield to recipient wallets if above user set threshold.\n                Eligible for upkeep means enough time(payment interval) has passed since their last upkeep.\n    */\n    function upkeep() external override {\n        if (upkeepDisabled) revert YieldStreamer_UpkeepDisabled();\n\n        uint256 totalGOHM;\n        uint256 depositLength = activeDepositIds.length;\n\n        for (uint256 i = 0; i < depositLength; i++) {\n            uint256 currentId = activeDepositIds[i];\n\n            if (_isUpkeepEligible(currentId)) {\n                totalGOHM += redeemableBalance(currentId);\n            }\n        }\n\n        uint256 feeToDao = (totalGOHM * feeToDaoPercent) / sixDecimalMaxNumber;\n        IERC20(gOHM).safeTransfer(authority.governor(), feeToDao);\n\n        uint256 totalOhmToSwap = staking.unstake(address(this), totalGOHM - feeToDao, false, false);\n\n        (, int256 ohmOraclePrice, , , ) = priceConverterOracleWrapper.latestRoundData();\n        uint256[] memory amounts = sushiRouter.swapExactTokensForTokens(\n            totalOhmToSwap,\n            (uint256(ohmOraclePrice) * (sixDecimalMaxNumber - maxSwapSlippagePercent)) / sixDecimalMaxNumber,\n            sushiRouterPath,\n            address(this),\n            block.timestamp\n        );\n\n        for (uint256 i = 0; i < depositLength; i++) {\n            // TODO: Is there a more gas efficient way than looping through this again and checking same condition\n            uint256 currentId = activeDepositIds[i];\n\n            if (_isUpkeepEligible(currentId)) {\n                RecipientInfo storage currentrecipientInfo = recipientInfo[currentId];\n\n                currentrecipientInfo.lastUpkeepTimestamp = uint128(block.timestamp);\n                currentrecipientInfo.unclaimedStreamTokens += uint128(\n                    (amounts[1] * _redeemYield(currentId)) / totalGOHM\n                );\n\n                if (currentrecipientInfo.unclaimedStreamTokens >= currentrecipientInfo.userMinimumAmountThreshold) {\n                    uint256 streamTokensToSend = currentrecipientInfo.unclaimedStreamTokens;\n                    currentrecipientInfo.unclaimedStreamTokens = 0;\n                    IERC20(streamToken).safeTransfer(currentrecipientInfo.recipientAddress, streamTokensToSend);\n                }\n            }\n        }\n\n        emit UpkeepComplete(block.timestamp);\n    }\n\n    /************************\n     * View Functions\n     ************************/\n\n    /**\n        @notice Returns the total amount of yield in gOhm the user can withdraw from all deposits. \n                Does not include harvestable stream tokens which is found in recipientInfo.\n        @param recipient_ Address of recipient.\n    */\n    function totalRedeemableBalance(address recipient_) external view override returns (uint256 totalGOHM) {\n        for (uint256 i = 0; i < recipientIds[recipient_].length; i++) {\n            totalGOHM += redeemableBalance(recipientIds[recipient_][i]);\n        }\n    }\n\n    /**\n        @notice Gets the number of deposits eligible for upkeep and amount of ohm of yield available to swap.\n                Eligible for upkeep means enough time(payment interval of deposit) has passed since last upkeep.\n        @return numberOfDepositsEligible : number of deposits eligible for upkeep.\n        @return amountOfYieldToSwap : total amount of yield in gOHM ready to be swapped in next upkeep.\n     */\n    function upkeepEligibility() external view returns (uint256 numberOfDepositsEligible, uint256 amountOfYieldToSwap) {\n        for (uint256 i = 0; i < activeDepositIds.length; i++) {\n            if (_isUpkeepEligible(activeDepositIds[i])) {\n                numberOfDepositsEligible++;\n                amountOfYieldToSwap += redeemableBalance(activeDepositIds[i]);\n            }\n        }\n    }\n\n    /**\n        @notice Returns the outstanding yield of a deposit.\n        @param id_ Id of the deposit.\n     */\n    function redeemableBalance(uint256 id_) public view override returns (uint256) {\n        return _getOutstandingYield(depositInfo[id_].principalAmount, depositInfo[id_].agnosticAmount);\n    }\n\n    /**\n        @notice Get deposits principal amount in gOhm\n        @param id_ Id of the deposit.\n     */\n    function getPrincipalInGOHM(uint256 id_) external view returns (uint256) {\n        return IgOHM(gOHM).balanceTo(depositInfo[id_].principalAmount);\n    }\n\n    /**\n        @notice Returns whether deposit id is eligible for upkeep.\n                Eligible for upkeep means enough time(payment interval of deposit) has passed since last upkeep.\n        @return bool\n     */\n    function _isUpkeepEligible(uint256 id_) internal view returns (bool) {\n        return block.timestamp >= recipientInfo[id_].lastUpkeepTimestamp + recipientInfo[id_].paymentInterval;\n    }\n\n    /**\n        @notice Returns the array of deposit id's belonging to the recipient\n        @return uint256[] array of recipient Id's\n     */\n    function getRecipientIds(address recipient_) external view returns (uint256[] memory) {\n        return recipientIds[recipient_];\n    }\n\n    /************************\n     * Restricted Setter Functions\n     ************************/\n\n    /**\n        @notice Setter for maxSwapSlippagePercent.\n        @param slippagePercent_ new slippage value is a percentage with 6 decimals. 1e6 = 100%\n    */\n    function setMaxSwapSlippagePercent(uint256 slippagePercent_) external onlyGovernor {\n        if (slippagePercent_ > sixDecimalMaxNumber) revert YieldStreamer_InvalidAmount();\n        maxSwapSlippagePercent = slippagePercent_;\n    }\n\n    /**\n        @notice Setter for feeToDaoPercent.\n        @param feePercent_ new fee value is a percentage with 6 decimals. 1e6 = 100%\n    */\n    function setFeeToDaoPercent(uint256 feePercent_) external onlyGovernor {\n        if (feePercent_ > sixDecimalMaxNumber) revert YieldStreamer_InvalidAmount();\n        feeToDaoPercent = feePercent_;\n    }\n\n    /**\n        @notice Setter for minimumTokenThreshold.\n        @param minimumTokenThreshold_ new minimumTokenThreshold value.\n    */\n    function setminimumTokenThreshold(uint256 minimumTokenThreshold_) external onlyGovernor {\n        minimumTokenThreshold = minimumTokenThreshold_;\n    }\n\n    /************************\n     * Emergency Functions\n     ************************/\n\n    function emergencyShutdown(bool active_) external onlyGovernor {\n        depositDisabled = active_;\n        withdrawDisabled = active_;\n        upkeepDisabled = active_;\n        emit EmergencyShutdown(active_);\n    }\n\n    function disableDeposits(bool active_) external onlyGovernor {\n        depositDisabled = active_;\n    }\n\n    function disableWithdrawals(bool active_) external onlyGovernor {\n        withdrawDisabled = active_;\n    }\n\n    function disableUpkeep(bool active_) external onlyGovernor {\n        upkeepDisabled = active_;\n    }\n}\n"
    },
    "contracts/StakingDistributor.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.10;\n\nimport \"./interfaces/IERC20.sol\";\nimport \"./interfaces/ITreasury.sol\";\nimport \"./interfaces/IStaking.sol\";\nimport \"./interfaces/IUniswapV2Pair.sol\";\n\nimport \"./types/OlympusAccessControlled.sol\";\n\n/// @notice Updated distributor adds the ability to mint and sync\n///         into Uniswap V2-style liquidity pools, removing the\n///         opportunity-cost dilemma of providing liquidity for\n///         OHM, as well as patches a small bug in the staking contract\n///         that pulls forward an amount of the next epoch rewards. Note that\n///         this implementation bases staking reward distributions on staked supply.\ncontract Distributor is OlympusAccessControlled {\n    error No_Rebase_Occurred();\n    error Only_Staking();\n    error Not_Unlocked();\n    error Sanity_Check();\n    error Adjustment_Limit();\n    error Adjustment_Underflow();\n    error Not_Permissioned();\n\n    struct Adjust {\n        bool add; // whether to add or subtract from the reward rate\n        uint256 rate; // the amount to add or subtract per epoch\n        uint256 target; // the resulting reward rate\n    }\n\n    /* ====== VARIABLES ====== */\n\n    /// The OHM Token\n    IERC20 private immutable ohm;\n    /// The Olympus Treasury\n    ITreasury private immutable treasury;\n    /// The OHM Staking Contract\n    address private immutable staking;\n\n    /// The % to increase balances per epoch\n    uint256 public rewardRate;\n    /// Liquidity pools to receive rewards\n    address[] public pools;\n\n    /// Information about adjusting reward rate\n    Adjust public adjustment;\n    /// A bounty for keepers to call the triggerRebase() function\n    uint256 public bounty;\n\n    uint256 private constant DENOMINATOR = 1_000_000;\n\n    constructor(\n        ITreasury _treasury,\n        IERC20 _ohm,\n        address _staking,\n        IOlympusAuthority _authority,\n        uint256 _initialRate\n    ) OlympusAccessControlled(_authority) {\n        treasury = _treasury;\n        ohm = _ohm;\n        staking = _staking;\n        rewardRate = _initialRate;\n    }\n\n    /* ====== PUBLIC FUNCTIONS ====== */\n\n    /// @notice Patch to trigger rebases via distributor. There is an error in Staking's\n    ///         `stake` function which pulls forward part of the rebase for the next epoch.\n    ///         This patch triggers a rebase by calling unstake (which does not have the issue).\n    ///         The patch also restricts `distribute` to only be able to be called from a tx\n    ///         originating this function.\n\n    bool private unlockRebase; // restricts distribute() to only this call\n\n    function triggerRebase() external {\n        unlockRebase = true;\n        IStaking(staking).unstake(msg.sender, 0, true, true); // Give the caller the bounty ohm.\n        if(unlockRebase) revert No_Rebase_Occurred();\n    }\n\n    /* ====== GUARDED FUNCTIONS ====== */\n\n    /// @notice send epoch reward to staking contract\n    function distribute() external {\n        if (msg.sender != staking) revert Only_Staking();\n        if (!unlockRebase) revert Not_Unlocked();\n\n        treasury.mint(staking, nextRewardFor(staking));\n\n        // mint to pools and sync\n        //\n        // this removes opportunity cost for liquidity providers by\n        // sending rebase rewards directly into the liquidity pool\n        //\n        // note that this does not add additional emissions (user could\n        // be staked instead and get the same tokens)\n\n        for (uint256 i = 0; i < pools.length; i++) {\n            address pool = pools[i];\n            if (pool != address(0)) {\n                treasury.mint(pool, nextRewardFor(pool));\n                IUniswapV2Pair(pool).sync();\n            }\n        }\n\n        if (adjustment.rate != 0) {\n            adjust();\n        }\n\n        unlockRebase = false;\n    }\n\n    function retrieveBounty() external returns (uint256) {\n        if (msg.sender != staking) revert Only_Staking();\n        // If the distributor bounty is > 0, mint it for the staking contract.\n        if (bounty > 0) {\n            treasury.mint(staking, bounty);\n        }\n\n        return bounty;\n    }\n\n    /* ====== INTERNAL FUNCTIONS ====== */\n\n    /// @notice increment reward rate for collector\n    function adjust() internal {\n        if (adjustment.add) {\n            // if rate should increase\n            rewardRate += adjustment.rate; // raise rate\n            if (rewardRate >= adjustment.target) {\n                // if target met\n                adjustment.rate = 0; // turn off adjustment\n                rewardRate = adjustment.target; // set to target\n            }\n        } else {\n            // if rate should decrease\n            if (rewardRate > adjustment.rate) {\n                // protect from underflow\n                rewardRate -= adjustment.rate; // lower rate\n            } else {\n                rewardRate = 0;\n            }\n\n            if (rewardRate <= adjustment.target) {\n                // if target met\n                adjustment.rate = 0; // turn off adjustment\n                rewardRate = adjustment.target; // set to target\n            }\n        }\n    }\n\n    /* ====== VIEW FUNCTIONS ====== */\n\n    /// @notice view function for next reward for an address\n    function nextRewardFor(address who) public view returns (uint256) {\n        return (ohm.balanceOf(who) * rewardRate) / DENOMINATOR;\n    }\n\n    /* ====== POLICY FUNCTIONS ====== */\n\n    /// @notice set bounty to incentivize keepers\n    function setBounty(uint256 _bounty) external onlyGovernor {\n        bounty = _bounty;\n    }\n\n    /// @notice sets the liquidity pools for mint and sync\n    /// @dev    note that this overwrites the entire list (!!)\n    function setPools(address[] calldata _pools) external onlyGovernor {\n        pools = _pools;\n    }\n\n    /// @notice removes a pool from the list\n    function removePool(uint256 index, address pool) external onlyGovernor {\n        if (pools[index] != pool) revert Sanity_Check();\n        pools[index] = address(0);\n    }\n\n    /// @notice adds a pool to the list\n    /// @dev    note you should find an empty slot offchain before calling\n    /// @dev    if there are no empty slots, pass in an occupied index to push\n    function addPool(uint256 index, address pool) external onlyGovernor {\n        // we want to overwrite slots where possible\n        if (pools[index] == address(0)) {\n            pools[index] = pool;\n        } else {\n            // if the passed in slot is not empty, push to the end\n            pools.push(pool);\n        }\n    }\n\n    /// @notice set adjustment info for a collector's reward rate\n    function setAdjustment(\n        bool _add,\n        uint256 _rate,\n        uint256 _target\n    ) external {\n        if (msg.sender != authority.governor() && msg.sender != authority.guardian()) revert Not_Permissioned();\n        if (msg.sender == authority.guardian() && _rate > (rewardRate * 25) / 1000) revert Adjustment_Limit();\n        if (!_add && _rate > rewardRate) revert Adjustment_Underflow();\n\n        adjustment = Adjust({add: _add, rate: _rate, target: _target});\n    }\n}\n"
    },
    "contracts/TreasuryExtender.sol": {
      "content": "pragma solidity ^0.8.10;\n\n// interfaces\nimport \"./interfaces/IERC20.sol\";\nimport \"./interfaces/ITreasury.sol\";\nimport \"./interfaces/IAllocator.sol\";\nimport \"./interfaces/ITreasuryExtender.sol\";\n\n// types\nimport \"./types/OlympusAccessControlledV2.sol\";\n\n// libraries\nimport \"./libraries/SafeERC20.sol\";\n\nerror TreasuryExtender_AllocatorOffline();\nerror TreasuryExtender_AllocatorNotActivated();\nerror TreasuryExtender_AllocatorNotOffline();\nerror TreasuryExtender_AllocatorRegistered(uint256 id);\nerror TreasuryExtender_OnlyAllocator(uint256 id, address sender);\nerror TreasuryExtender_MaxAllocation(uint256 allocated, uint256 limit);\n\n/**\n * @title Treasury Extender\n * @notice\n *  This contract serves as an accounting and management contract which\n *  will interact with the Olympus Treasury to fund Allocators.\n *\n *  Accounting:\n *  For each Allocator there are multiple deposit IDs referring to individual tokens,\n *  for each deposit ID we record 5 distinct values grouped into 3 fields,\n *  together grouped as AllocatorData:\n *\n *  AllocatorLimits { allocated, loss } - This is the maximum amount\n *  an Allocator should have allocated at any point, and also the maximum\n *  loss an allocator should experience without automatically shutting down.\n *\n *  AllocatorPerformance { gain, loss } - This is the current gain (total - allocated)\n *  and the loss the Allocator sustained over its time of operation.\n *\n *  AllocatorHoldings { allocated } - This is the amount of tokens an Allocator\n *  has currently been allocated by the Extender.\n *\n *  Important: The above is only tracked in the underlying token specified by the ID,\n *  (see BaseAllocator.sol) while rewards are retrievable by the standard ERC20 functions.\n *  The point is that we only exactly track that which exits the Treasury.\n */\ncontract TreasuryExtender is OlympusAccessControlledV2, ITreasuryExtender {\n    using SafeERC20 for IERC20;\n\n    // The Olympus Treasury.\n    ITreasury public immutable treasury;\n\n    // Enumerable Allocators according to deposit IDs.\n    /// @dev NOTE: Allocator enumeration starts from index 1.\n    IAllocator[] public allocators;\n\n    // Get an an Allocator's Data for for an Allocator and deposit ID\n    mapping(IAllocator => mapping(uint256 => AllocatorData)) public allocatorData;\n\n    constructor(address treasuryAddress, address authorityAddress)\n        OlympusAccessControlledV2(IOlympusAuthority(authorityAddress))\n    {\n        treasury = ITreasury(treasuryAddress);\n        // This nonexistent allocator at address(0) is pushed\n        // as a placeholder so enumeration may start from index 1.\n        allocators.push(IAllocator(address(0)));\n    }\n\n    //// CHECKS\n\n    function _allocatorActivated(AllocatorStatus status) internal pure {\n        if (AllocatorStatus.ACTIVATED != status) revert TreasuryExtender_AllocatorNotActivated();\n    }\n\n    function _allocatorOffline(AllocatorStatus status) internal pure {\n        if (AllocatorStatus.OFFLINE != status) revert TreasuryExtender_AllocatorNotOffline();\n    }\n\n    function _onlyAllocator(\n        IAllocator byStatedId,\n        address sender,\n        uint256 id\n    ) internal pure {\n        if (IAllocator(sender) != byStatedId) revert TreasuryExtender_OnlyAllocator(id, sender);\n    }\n\n    //// FUNCTIONS\n\n    /**\n     * @notice\n     *  Registers an Allocator. Adds a deposit id and prepares storage slots for writing.\n     *  Does not activate the Allocator.\n     * @dev\n     *  Calls `addId` from `IAllocator` with the index of the deposit in `allocators`\n     * @param newAllocator the Allocator to be registered\n     */\n    function registerDeposit(address newAllocator) external override onlyGuardian {\n        // reads\n        IAllocator allocator = IAllocator(newAllocator);\n\n        // effects\n        allocators.push(allocator);\n\n        uint256 id = allocators.length - 1;\n\n        // interactions\n        allocator.addId(id);\n\n        // events\n        emit NewDepositRegistered(newAllocator, address(allocator.tokens()[allocator.tokenIds(id)]), id);\n    }\n\n    /**\n     * @notice\n     *  Sets an Allocators AllocatorLimits.\n     *  AllocatorLimits is part of AllocatorData, variable meanings follow:\n     *  allocated - The maximum amount a Guardian may allocate this Allocator from Treasury.\n     *  loss - The maximum loss amount this Allocator can take.\n     * @dev\n     *  Can only be called while the Allocator is offline.\n     * @param id the deposit id to set AllocatorLimits for\n     * @param limits the AllocatorLimits to set\n     */\n    function setAllocatorLimits(uint256 id, AllocatorLimits calldata limits) external override onlyGuardian {\n        IAllocator allocator = allocators[id];\n\n        // checks\n        _allocatorOffline(allocator.status());\n\n        // effects\n        allocatorData[allocator][id].limits = limits;\n\n        // events\n        emit AllocatorLimitsChanged(id, limits.allocated, limits.loss);\n    }\n\n    /**\n     * @notice\n     *  Reports an Allocators status to the Extender.\n     *  Updates Extender state accordingly.\n     * @dev\n     *  Can only be called while the Allocator is activated or migrating.\n     *  The idea is that first the Allocator updates its own state, then\n     *  it reports this state to the Extender, which then updates its own state.\n     *\n     *  There is 3 different combinations the Allocator may report:\n     *\n     *  (gain + loss) == 0, the Allocator will NEVER report this state\n     *  gain > loss, gain is reported and incremented but allocated not.\n     *  loss > gain, loss is reported, allocated and incremented.\n     *  loss == gain == type(uint128).max , migration case, zero out gain, loss, allocated\n     *\n     *  NOTE: please take care to properly calculate loss by, say, only reporting loss above a % threshold\n     *        of allocated. This is to serve as a low pass filter of sorts to ignore noise in price movements.\n     *  NOTE: when migrating the next Allocator should report his state to the Extender, in say an `_activate` call.\n     *\n     * @param id the deposit id of the token to report state for\n     * @param gain the gain the Allocator has made in allocated token\n     * @param loss the loss the Allocator has sustained in allocated token\n     */\n    function report(\n        uint256 id,\n        uint128 gain,\n        uint128 loss\n    ) external override {\n        // reads\n        IAllocator allocator = allocators[id];\n        AllocatorData storage data = allocatorData[allocator][id];\n        AllocatorPerformance memory perf = data.performance;\n        AllocatorStatus status = allocator.status();\n\n        // checks\n        _onlyAllocator(allocator, msg.sender, id);\n        if (status == AllocatorStatus.OFFLINE) revert TreasuryExtender_AllocatorOffline();\n\n        // EFFECTS\n        if (gain >= loss) {\n            // MIGRATION\n            // according to above gain must equal loss because\n            // gain can't be larger than max uint128 value\n            if (loss == type(uint128).max) {\n                AllocatorData storage newAllocatorData = allocatorData[allocators[allocators.length - 1]][id];\n\n                newAllocatorData.holdings.allocated = data.holdings.allocated;\n                newAllocatorData.performance.gain = data.performance.gain;\n                data.holdings.allocated = 0;\n\n                perf.gain = 0;\n                perf.loss = 0;\n\n                emit AllocatorReportedMigration(id);\n\n                // GAIN\n            } else {\n                perf.gain += gain;\n\n                emit AllocatorReportedGain(id, gain);\n            }\n\n            // LOSS\n        } else {\n            data.holdings.allocated -= loss;\n\n            perf.loss += loss;\n\n            emit AllocatorReportedLoss(id, loss);\n        }\n\n        data.performance = perf;\n    }\n\n    /**\n     * @notice\n     *  Requests funds from the Olympus Treasury to fund an Allocator.\n     * @dev\n     *  Can only be called while the Allocator is activated.\n     *  Can only be called by the Guardian.\n     *\n     *  This function is going to allocate an `amount` of deposit id tokens to the Allocator and\n     *  properly record this in storage. This done so that at any point, we know exactly\n     *  how much was initially allocated and also how much value is allocated in total.\n     *\n     *  The related functions are `getAllocatorAllocated` and `getTotalValueAllocated`.\n     *\n     *  To note is also the `_allocatorBelowLimit` check.\n     * @param id the deposit id of the token to fund allocator with\n     * @param amount the amount of token to withdraw, the token is known in the Allocator\n     */\n    function requestFundsFromTreasury(uint256 id, uint256 amount) external override onlyGuardian {\n        // reads\n        IAllocator allocator = allocators[id];\n        AllocatorData memory data = allocatorData[allocator][id];\n        address token = address(allocator.tokens()[allocator.tokenIds(id)]);\n        uint256 value = treasury.tokenValue(token, amount);\n\n        // checks\n        _allocatorActivated(allocator.status());\n        _allocatorBelowLimit(data, amount);\n\n        // interaction (withdrawing)\n        treasury.manage(token, amount);\n\n        // effects\n        allocatorData[allocator][id].holdings.allocated += amount;\n\n        // interaction (depositing)\n        IERC20(token).safeTransfer(address(allocator), amount);\n\n        // events\n        emit AllocatorFunded(id, amount, value);\n    }\n\n    /**\n     * @notice\n     *  Returns funds from an Allocator to the Treasury.\n     * @dev\n     *  External hook: Logic is handled in the internal function.\n     *  Can only be called by the Guardian.\n     *\n     *  This function is going to withdraw `amount` of allocated token from an Allocator\n     *  back to the Treasury. Prior to calling this function, `deallocate` should be called,\n     *  in order to prepare the funds for withdrawal.\n     *\n     *  The maximum amount which can be withdrawn is `gain` + `allocated`.\n     *  `allocated` is decremented first after which `gain` is decremented in the case\n     *  that `allocated` is not sufficient.\n     * @param id the deposit id of the token to fund allocator with\n     * @param amount the amount of token to withdraw, the token is known in the Allocator\n     */\n    function returnFundsToTreasury(uint256 id, uint256 amount) external override onlyGuardian {\n        // reads\n        IAllocator allocator = allocators[id];\n        uint256 allocated = allocatorData[allocator][id].holdings.allocated;\n        uint128 gain = allocatorData[allocator][id].performance.gain;\n        address token = address(allocator.tokens()[allocator.tokenIds(id)]);\n\n        if (amount > allocated) {\n            amount -= allocated;\n            if (amount > gain) {\n                amount = allocated + gain;\n                gain = 0;\n            } else {\n                // yes, amount should never > gain, we have safemath\n                gain -= uint128(amount);\n                amount += allocated;\n            }\n            allocated = 0;\n        } else {\n            allocated -= amount;\n        }\n\n        uint256 value = treasury.tokenValue(token, amount);\n\n        // checks\n        _allowTreasuryWithdrawal(IERC20(token));\n\n        // interaction (withdrawing)\n        IERC20(token).safeTransferFrom(address(allocator), address(this), amount);\n\n        // effects\n        allocatorData[allocator][id].holdings.allocated = allocated;\n        if (allocated == 0) allocatorData[allocator][id].performance.gain = gain;\n\n        // interaction (depositing)\n        assert(treasury.deposit(amount, token, value) == 0);\n\n        // events\n        emit AllocatorWithdrawal(id, amount, value);\n    }\n\n    /**\n     * @notice\n     *  Returns rewards from an Allocator to the Treasury.\n     *  Also see `_returnRewardsToTreasury`.\n     * @dev\n     *  External hook: Logic is handled in the internal function.\n     *  Can only be called by the Guardian.\n     * @param id the deposit id of the token to fund allocator with\n     * @param token the address of the reward token to withdraw\n     * @param amount the amount of the reward token to withdraw\n     */\n    function returnRewardsToTreasury(\n        uint256 id,\n        address token,\n        uint256 amount\n    ) external {\n        _returnRewardsToTreasury(allocators[id], IERC20(token), amount);\n    }\n\n    /**\n     * @notice\n     *  Returns rewards from an Allocator to the Treasury.\n     *  Also see `_returnRewardsToTreasury`.\n     * @dev\n     *  External hook: Logic is handled in the internal function.\n     *  Can only be called by the Guardian.\n     * @param allocatorAddress the address of the Allocator to returns rewards from\n     * @param token the address of the reward token to withdraw\n     * @param amount the amount of the reward token to withdraw\n     */\n    function returnRewardsToTreasury(\n        address allocatorAddress,\n        address token,\n        uint256 amount\n    ) external {\n        _returnRewardsToTreasury(IAllocator(allocatorAddress), IERC20(token), amount);\n    }\n\n    /**\n     * @notice\n     *  Get an Allocators address by it's ID.\n     * @dev\n     *  Our first Allocator is at index 1, NOTE: 0 is a placeholder.\n     * @param id the id of the allocator, NOTE: valid interval: 1 =< id < allocators.length\n     * @return allocatorAddress the allocator's address\n     */\n    function getAllocatorByID(uint256 id) external view override returns (address allocatorAddress) {\n        allocatorAddress = address(allocators[id]);\n    }\n\n    /**\n     * @notice\n     *  Get the total number of Allocators ever registered.\n     * @dev\n     *  Our first Allocator is at index 1, 0 is a placeholder.\n     * @return total number of allocators ever registered\n     */\n    function getTotalAllocatorCount() external view returns (uint256) {\n        return allocators.length;\n    }\n\n    /**\n     * @notice\n     *  Get an Allocators limits.\n     * @dev\n     *  For an explanation of AllocatorLimits, see `setAllocatorLimits`\n     * @return the Allocator's limits\n     */\n    function getAllocatorLimits(uint256 id) external view override returns (AllocatorLimits memory) {\n        return allocatorData[allocators[id]][id].limits;\n    }\n\n    /**\n     * @notice\n     *  Get an Allocators performance.\n     * @dev\n     *  An Allocator's performance is the amount of `gain` and `loss` it has sustained in its\n     *  lifetime. `gain` is the amount of allocated tokens (underlying) acquired, while\n     *  `loss` is the amount lost. `gain` and `loss` are incremented separately.\n     *  Thus, overall performance can be gauged as gain - loss\n     * @return the Allocator's performance\n     */\n    function getAllocatorPerformance(uint256 id) external view override returns (AllocatorPerformance memory) {\n        return allocatorData[allocators[id]][id].performance;\n    }\n\n    /**\n     * @notice\n     *  Get an Allocators amount allocated.\n     * @dev\n     *  This is simply the amount of `token` which was allocated to the allocator.\n     * @return the Allocator's amount allocated\n     */\n    function getAllocatorAllocated(uint256 id) external view override returns (uint256) {\n        return allocatorData[allocators[id]][id].holdings.allocated;\n    }\n\n    /**\n     * @notice\n     *  Returns rewards from an Allocator to the Treasury.\n     * @dev\n     *  External hook: Logic is handled in the internal function.\n     *  Can only be called by the Guardian.\n     *\n     *  The assumption is that the reward tokens being withdrawn are going to be\n     *  either deposited into the contract OR harvested into allocated (underlying).\n     *\n     *  For this reason we don't need anything other than `balanceOf`.\n     * @param allocator the Allocator to returns rewards from\n     * @param token the reward token to withdraw\n     * @param amount the amount of the reward token to withdraw\n     */\n    function _returnRewardsToTreasury(\n        IAllocator allocator,\n        IERC20 token,\n        uint256 amount\n    ) internal onlyGuardian {\n        // reads\n        uint256 balance = token.balanceOf(address(allocator));\n        amount = (balance < amount) ? balance : amount;\n        uint256 value = treasury.tokenValue(address(token), amount);\n\n        // checks\n        _allowTreasuryWithdrawal(token);\n\n        // interactions\n        token.safeTransferFrom(address(allocator), address(this), amount);\n        assert(treasury.deposit(amount, address(token), value) == 0);\n\n        // events\n        emit AllocatorRewardsWithdrawal(address(allocator), amount, value);\n    }\n\n    /**\n     * @notice\n     *  Approve treasury for withdrawing if token has not been approved.\n     * @param token Token to approve.\n     */\n    function _allowTreasuryWithdrawal(IERC20 token) internal {\n        if (token.allowance(address(this), address(treasury)) == 0) token.approve(address(treasury), type(uint256).max);\n    }\n\n    /**\n     * @notice\n     *  Check if token is below limit for allocation and if not approve it.\n     * @param data allocator data to check limits and amount allocated\n     * @param amount amount of tokens to allocate\n     */\n    function _allocatorBelowLimit(AllocatorData memory data, uint256 amount) internal pure {\n        uint256 newAllocated = data.holdings.allocated + amount;\n        if (newAllocated > data.limits.allocated)\n            revert TreasuryExtender_MaxAllocation(newAllocated, data.limits.allocated);\n    }\n}\n"
    },
    "contracts/types/BaseAllocator.sol": {
      "content": "pragma solidity ^0.8.10;\n\n// interfaces\nimport \"../interfaces/IAllocator.sol\";\nimport \"../interfaces/ITreasury.sol\";\n\n// types\nimport \"../types/OlympusAccessControlledV2.sol\";\n\n// libraries\nimport \"../libraries/SafeERC20.sol\";\n\nerror BaseAllocator_AllocatorNotActivated();\nerror BaseAllocator_AllocatorNotOffline();\nerror BaseAllocator_Migrating();\nerror BaseAllocator_NotMigrating();\nerror BaseAllocator_OnlyExtender(address sender);\n\n/**\n * @title BaseAllocator\n * @notice\n *  This abstract contract serves as a template for writing new Olympus Allocators.\n *  Many of the functionalities regarding handling of Treasury funds by the Guardian have\n *  been delegated to the `TreasuryExtender` contract, and thus an explanation for them can be found\n *  in `TreasuryExtender.sol`.\n *\n *  The main purpose of this abstract contract and the `IAllocator` interface is to provide\n *  a unified framework for how an Allocator should behave. Below an explanation of how\n *  we expect an Allocator to behave in general, mentioning the most important points.\n *\n *  Activation:\n *   - An Allocator is first deployed with all necessary arguments.\n *     Thereafter, each deposit is registered with the `TreasuryExtender`.\n *     This assigns a unique id for each deposit (set of allocations) in an Allocator.\n *   - Next, the Allocators allocation and loss limits are set via the extender function.\n *   - Finally, the Allocator is activated by calling `activate`.\n *\n *  Runtime:\n *   The Allocator is in communication with the Extender, it must inform the Extender\n *   what the status of the tokens is which were allocated. We only care about noting down\n *   their status in the Extender. A quick summary of the important functions on this topic:\n *\n *   - `update(uint256 id)` is the main function that deals with state reporting, where\n *     `_update(uint256 id)` is the internal function to implement, which should update Allocator\n *     internal state. `update(uint256 id)` then continues to report the Allocators state via `report`\n *     to the extender. `_update(uint256 id)` should handle _investment_ of funds present in Contract.\n *\n *   - `deallocate` should handle allocated token withdrawal, preparing the tokens to be withdrawn\n *     by the Extender. It is not necessary to handle approvals for this token, because it is automatically\n *     approved in the constructor. For other token withdrawals, it is assumed that reward tokens will\n *     either be sold into underlying (allocated) or that they will simply rest in the Contract, being reward tokens.\n *     Please also check function documentation.\n *\n *   - `rewardTokens` and `utilityTokens` should return the above mentioned simple reward tokens for the former case,\n *     while utility tokens should be those tokens which are continously reinvested or otherwise used by the contract\n *     in order to accrue more rewards. A reward token can also be a utility token, but then one must prepare them\n *     separately for withdrawal if they are to be returned to the treasury.\n *\n *  Migration & Deactivation:\n *   - `prepareMigration()` together with the virtual `_prepareMigration()` sets the state of the Allocator into\n *     MIGRATING, disabling further token deposits, enabling only withdrawals, and preparing all funds for withdrawal.\n *\n *   - `migrate` then executes the migration and also deactivates the Allocator.\n *\n *   - `deactivate` sets `status` to OFFLINE, meaning it simply deactivates the Allocator. It can be passed\n *     a panic boolean, meaning it handles deactivation logic in `deactivate`. The Allocator panic deactivates if\n *     this state if the loss limit is reached via `update`. The Allocator can otherwise also simply be deactivated\n *     and funds transferred back to the Treasury.\n *\n *  This was a short summary of the Allocator lifecycle.\n */\nabstract contract BaseAllocator is OlympusAccessControlledV2, IAllocator {\n    using SafeERC20 for IERC20;\n\n    // Indices which represent the ids of the deposits in the `TreasuryExtender`\n    uint256[] internal _ids;\n\n    // The allocated (underlying) tokens of the Allocator\n    IERC20[] internal _tokens;\n\n    // From deposit id to the token's id\n    mapping(uint256 => uint256) public tokenIds;\n\n    // Allocator status: OFFLINE, ACTIVATED, MIGRATING\n    AllocatorStatus public status;\n\n    // The extender with which the Allocator communicates.\n    ITreasuryExtender public immutable extender;\n\n    constructor(AllocatorInitData memory data) OlympusAccessControlledV2(data.authority) {\n        _tokens = data.tokens;\n        extender = data.extender;\n\n        for (uint256 i; i < data.tokens.length; i++) {\n            data.tokens[i].approve(address(data.extender), type(uint256).max);\n        }\n\n        emit AllocatorDeployed(address(data.authority), address(data.extender));\n    }\n\n    /////// MODIFIERS\n\n    modifier onlyExtender {\n\t_onlyExtender(msg.sender);\n\t_;\n    }\n\n    modifier onlyActivated {\n\t_onlyActivated(status);\n\t_;\n    }\n\n    modifier onlyOffline {\n\t_onlyOffline(status);\n\t_;\n    }\n\n    modifier notMigrating {\n\t_notMigrating(status);\n\t_;\n    }\n\n    modifier isMigrating {\n\t_isMigrating(status);\n\t_;\n    }\n\n    /////// VIRTUAL FUNCTIONS WHICH NEED TO BE IMPLEMENTED\n    /////// SORTED BY EXPECTED COMPLEXITY AND DEPENDENCY\n\n    /**\n     * @notice\n     *  Updates an Allocators state.\n     * @dev\n     *  This function should be implemented by the developer of the Allocator.\n     *  This function should fulfill the following purposes:\n     *   - invest token specified by deposit id\n     *   - handle rebalancing / harvesting for token as needed\n     *   - calculate gain / loss for token and return those values\n     *   - handle any other necessary runtime calculations, such as fees etc.\n     *\n     *  In essence, this function should update the main runtime state of the Allocator\n     *  so that everything is properly invested, harvested, accounted for.\n     * @param id the id of the deposit in the `TreasuryExtender`\n     */\n    function _update(uint256 id) internal virtual returns (uint128 gain, uint128 loss);\n\n    /**\n     * @notice\n     *  Deallocates tokens, prepares tokens for return to the Treasury.\n     * @dev\n     *  This function should deallocate (withdraw) `amounts` of each token so that they may be withdrawn\n     *  by the TreasuryExtender. Otherwise, this function may also prepare the withdraw if it is time-bound.\n     * @param amounts is the amount of each of token from `_tokens` to withdraw\n     */\n    function deallocate(uint256[] memory amounts) public virtual;\n\n    /**\n     * @notice\n     *  Handles deactivation logic for the Allocator.\n     */\n    function _deactivate(bool panic) internal virtual;\n\n    /**\n     * @notice\n     *  Handles migration preparatory logic.\n     * @dev\n     *  Within this function, the developer should arrange the withdrawal of all assets for migration.\n     *  A useful function, say, to be passed into this could be `deallocate` with all of the amounts,\n     *  so with n places for n-1 utility tokens + 1 allocated token, maxed out.\n     */\n    function _prepareMigration() internal virtual;\n\n    /**\n     * @notice\n     *  Should estimate total amount of Allocated tokens\n     * @dev\n     *  The difference between this and `treasury.getAllocatorAllocated`, is that the latter is a static\n     *  value recorded during reporting, but no data is available on _new_ amounts after reporting.\n     *  Thus, this should take into consideration the new amounts. This can be used for say aTokens.\n     * @param id the id of the deposit in `TreasuryExtender`\n     */\n    function amountAllocated(uint256 id) public view virtual returns (uint256);\n\n    /**\n     * @notice\n     *  Should return all reward token addresses\n     */\n    function rewardTokens() public view virtual returns (IERC20[] memory);\n\n    /**\n     * @notice\n     *  Should return all utility token addresses\n     */\n    function utilityTokens() public view virtual returns (IERC20[] memory);\n\n    /**\n     * @notice\n     *  Should return the Allocator name\n     */\n    function name() external view virtual returns (string memory);\n\n    /////// IMPLEMENTATION OPTIONAL\n\n    /**\n     * @notice\n     *  Should handle activation logic\n     * @dev\n     *  If there is a need to handle any logic during activation, this is the function you should implement it into\n     */\n    function _activate() internal virtual {}\n\n    /////// FUNCTIONS\n\n    /**\n     * @notice\n     *  Updates an Allocators state and reports to `TreasuryExtender` if necessary.\n     * @dev\n     *  Can only be called by the Guardian.\n     *  Can only be called while the Allocator is activated.\n     *\n     *  This function should update the Allocators internal state via `_update`, which should in turn\n     *  return the `gain` and `loss` the Allocator has sustained in underlying allocated `token` from `_tokens`\n     *  decided by the `id`.\n     *  Please check the docs on `_update` to see what its function should be.\n     *\n     *  `_lossLimitViolated` checks if the Allocators is above its loss limit and deactivates it in case\n     *  of serious losses. The loss limit should be set to some value which is unnacceptable to be lost\n     *  in the case of normal runtime and thus require a panic shutdown, whatever it is defined to be.\n     *\n     *  Lastly, the Allocator reports its state to the Extender, which handles gain, loss, allocated logic.\n     *  The documentation on this can be found in `TreasuryExtender.sol`.\n     * @param id the id of the deposit in `TreasuryExtender`\n     */\n    function update(uint256 id) external override onlyGuardian onlyActivated {\n        // effects\n        // handle depositing, harvesting, compounding logic inside of _update()\n        // if gain is in allocated then gain > 0 otherwise gain == 0\n        // we only use so we know initia\n        // loss always in allocated\n        (uint128 gain, uint128 loss) = _update(id);\n\n        if (_lossLimitViolated(id, loss)) {\n            deactivate(true);\n            return;\n        }\n\n        // interactions\n        // there is no interactions happening inside of report\n        // so allocator has no state changes to make after it\n        if (gain + loss > 0) extender.report(id, gain, loss);\n    }\n\n    /**\n     * @notice\n     *  Prepares the Allocator for token migration.\n     * @dev\n     *  This function prepares the Allocator for token migration by calling the to-be-implemented\n     *  `_prepareMigration`, which should logically withdraw ALL allocated (1) + utility AND reward tokens\n     *  from the contract. The ALLOCATED token and THE UTILITY TOKEN is going to be migrated, while the REWARD\n     *  tokens can be withdrawn by the Extender to the Treasury.\n     */\n    function prepareMigration() external override onlyGuardian notMigrating {\n        // effects\n        _prepareMigration();\n\n        status = AllocatorStatus.MIGRATING;\n    }\n\n    /**\n     * @notice\n     *  Migrates the allocated and all utility tokens to the next Allocator.\n     * @dev\n     *  The allocated token and the utility tokens will be migrated by this function, while it is\n     *  assumed that the reward tokens are either simply kept or already harvested into the underlying\n     *  essentially being the edge case of this contract. This contract is also going to report to the\n     *  Extender that a migration happened and as such it is important to follow the proper sequence of\n     *  migrating.\n     *\n     *  Steps to migrate:\n     *   - FIRST call `_prepareMigration()` to prepare funds for migration.\n     *   - THEN deploy the new Allocator and activate it according to the normal procedure.\n     *     NOTE: This is to be done RIGHT BEFORE migration as to avoid allocating to the wrong allocator.\n     *   - FINALLY call migrate. This is going to migrate the funds to the LAST allocator registered.\n     *   - Check if everything went fine.\n     *\n     *  End state should be that allocator amounts have been swapped for allocators, that gain + loss is netted out 0\n     *  for original allocator, and that the new allocators gain has been set to the original allocators gain.\n     *  We don't transfer the loss because we have the information how much was initially invested + gain,\n     *  and the new allocator didn't cause any loss thus we don't really need to add to it.\n     */\n    function migrate() external override onlyGuardian isMigrating {\n        // reads\n        IERC20[] memory utilityTokensArray = utilityTokens();\n        address newAllocator = extender.getAllocatorByID(extender.getTotalAllocatorCount() - 1);\n\tuint256 idLength = _ids.length;\n\tuint256 utilLength = utilityTokensArray.length;\n\n        // interactions\n        for (uint256 i; i < idLength; i++) {\n            IERC20 token = _tokens[i];\n\n            token.safeTransfer(newAllocator, token.balanceOf(address(this)));\n            extender.report(_ids[i], type(uint128).max, type(uint128).max);\n        }\n\n        for (uint256 i; i < utilLength; i++) {\n            IERC20 utilityToken = utilityTokensArray[i];\n            utilityToken.safeTransfer(newAllocator, utilityToken.balanceOf(address(this)));\n        }\n\n        // turn off Allocator\n        deactivate(false);\n\n        emit MigrationExecuted(newAllocator);\n    }\n\n    /**\n     * @notice\n     *  Activates the Allocator.\n     * @dev\n     *  Only the Guardian can call this.\n     *\n     *  Add any logic you need during activation, say interactions with Extender or something else,\n     *  in the virtual method `_activate`.\n     */\n    function activate() external override onlyGuardian onlyOffline {\n        // effects\n        _activate();\n        status = AllocatorStatus.ACTIVATED;\n\n        emit AllocatorActivated();\n    }\n\n    /**\n     * @notice\n     *  Adds a deposit ID to the Allocator.\n     * @dev\n     *  Only the Extender calls this.\n     * @param id id to add to the allocator\n     */\n    function addId(uint256 id) external override onlyExtender {\n        _ids.push(id);\n        tokenIds[id] = _ids.length - 1;\n    }\n\n    /**\n     * @notice\n     *  Returns all deposit IDs registered with the Allocator.\n     * @return the deposit IDs registered\n     */\n    function ids() external view override returns (uint256[] memory) {\n        return _ids;\n    }\n\n    /**\n     * @notice\n     *  Returns all tokens registered with the Allocator.\n     * @return the tokens\n     */\n    function tokens() external view override returns (IERC20[] memory) {\n        return _tokens;\n    }\n\n    /**\n     * @notice\n     *  Deactivates the Allocator.\n     * @dev\n     *  Only the Guardian can call this.\n     *\n     *  Add any logic you need during deactivation, say interactions with Extender or something else,\n     *  in the virtual method `_deactivate`. Be careful to specifically use the internal or public function\n     *  depending on what you need.\n     * @param panic should panic logic be executed\n     */\n    function deactivate(bool panic) public override onlyGuardian {\n        // effects\n        _deactivate(panic);\n        status = AllocatorStatus.OFFLINE;\n\n        emit AllocatorDeactivated(panic);\n    }\n\n    /**\n     * @notice\n     *  Getter for Allocator version.\n     * @return Returns the Allocators version.\n     */\n    function version() public pure override returns (string memory) {\n        return \"v2.0.0\";\n    }\n\n    /**\n     * @notice\n     *  Internal check if the loss limit has been violated by the Allocator.\n     * @dev\n     *  Called as part of `update`. The rule is that the already sustained loss + newly sustained\n     *  has to be larger or equal to the limit to break the contract.\n     * @param id deposit id as in `TreasuryExtender`\n     * @param loss the amount of newly sustained loss\n     * @return true if the the loss limit has been broken\n     */\n    function _lossLimitViolated(uint256 id, uint128 loss) internal returns (bool) {\n        // read\n        uint128 lastLoss = extender.getAllocatorPerformance(id).loss;\n\n        // events\n        if ((loss + lastLoss) >= extender.getAllocatorLimits(id).loss) {\n            emit LossLimitViolated(lastLoss, loss, amountAllocated(tokenIds[id]));\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * @notice\n     *  Internal check to see if sender is extender.\n     */\n    function _onlyExtender(address sender) internal view {\n        if (sender != address(extender)) revert BaseAllocator_OnlyExtender(sender);\n    }\n\n    /**\n     * @notice\n     *  Internal check to see if allocator is activated.\n     */\n    function _onlyActivated(AllocatorStatus inputStatus) internal pure {\n        if (inputStatus != AllocatorStatus.ACTIVATED) revert BaseAllocator_AllocatorNotActivated();\n    }\n\n    /**\n     * @notice\n     *  Internal check to see if allocator is offline.\n     */\n    function _onlyOffline(AllocatorStatus inputStatus) internal pure {\n        if (inputStatus != AllocatorStatus.OFFLINE) revert BaseAllocator_AllocatorNotOffline();\n    }\n\n    /**\n     * @notice\n     *  Internal check to see if allocator is not migrating.\n     */\n    function _notMigrating(AllocatorStatus inputStatus) internal pure {\n        if (inputStatus == AllocatorStatus.MIGRATING) revert BaseAllocator_Migrating();\n    }\n\n    /**\n     * @notice\n     *  Internal check to see if allocator is migrating.\n     */\n    function _isMigrating(AllocatorStatus inputStatus) internal pure {\n        if (inputStatus != AllocatorStatus.MIGRATING) revert BaseAllocator_NotMigrating();\n    }\n}\n"
    },
    "contracts/types/FrontEndRewarder.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport \"../types/OlympusAccessControlled.sol\";\nimport \"../interfaces/IERC20.sol\";\n\nabstract contract FrontEndRewarder is OlympusAccessControlled {\n    /* ========= STATE VARIABLES ========== */\n\n    uint256 public daoReward; // % reward for dao (3 decimals: 100 = 1%)\n    uint256 public refReward; // % reward for referrer (3 decimals: 100 = 1%)\n    mapping(address => uint256) public rewards; // front end operator rewards\n    mapping(address => bool) public whitelisted; // whitelisted status for operators\n\n    IERC20 internal immutable ohm; // reward token\n\n    constructor(IOlympusAuthority _authority, IERC20 _ohm) OlympusAccessControlled(_authority) {\n        ohm = _ohm;\n    }\n\n    /* ========= EXTERNAL FUNCTIONS ========== */\n\n    // pay reward to front end operator\n    function getReward() external {\n        uint256 reward = rewards[msg.sender];\n\n        rewards[msg.sender] = 0;\n        ohm.transfer(msg.sender, reward);\n    }\n\n    /* ========= INTERNAL ========== */\n\n    /**\n     * @notice add new market payout to user data\n     */\n    function _giveRewards(uint256 _payout, address _referral) internal returns (uint256) {\n        // first we calculate rewards paid to the DAO and to the front end operator (referrer)\n        uint256 toDAO = (_payout * daoReward) / 1e4;\n        uint256 toRef = (_payout * refReward) / 1e4;\n\n        // and store them in our rewards mapping\n        if (whitelisted[_referral]) {\n            rewards[_referral] += toRef;\n            rewards[authority.guardian()] += toDAO;\n        } else {\n            // the DAO receives both rewards if referrer is not whitelisted\n            rewards[authority.guardian()] += toDAO + toRef;\n        }\n        return toDAO + toRef;\n    }\n\n    /**\n     * @notice set rewards for front end operators and DAO\n     */\n    function setRewards(uint256 _toFrontEnd, uint256 _toDAO) external onlyGovernor {\n        refReward = _toFrontEnd;\n        daoReward = _toDAO;\n    }\n\n    /**\n     * @notice add or remove addresses from the reward whitelist\n     */\n    function whitelist(address _operator) external onlyPolicy {\n        whitelisted[_operator] = !whitelisted[_operator];\n    }\n}\n"
    },
    "contracts/types/Governable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.7.5;\n\nimport \"../interfaces/IGovernable.sol\";\n\ncontract Governable is IGovernable {\n    address internal _governor;\n    address internal _newGovernor;\n\n    event GovernorPushed(address indexed previousGovernor, address indexed newGovernor);\n    event GovernorPulled(address indexed previousGovernor, address indexed newGovernor);\n\n    constructor() {\n        _governor = msg.sender;\n        emit GovernorPulled(address(0), _governor);\n    }\n\n    /* ========== GOVERNOR ========== */\n\n    function governor() public view override returns (address) {\n        return _governor;\n    }\n\n    modifier onlyGovernor() {\n        require(_governor == msg.sender, \"Governable: caller is not the governor\");\n        _;\n    }\n\n    function renounceGovernor() public virtual override onlyGovernor {\n        emit GovernorPulled(_governor, address(0));\n        _governor = address(0);\n        _newGovernor = address(0);\n    }\n\n    function pushGovernor(address newGovernor_) public virtual override onlyGovernor {\n        emit GovernorPushed(_governor, newGovernor_);\n        _newGovernor = newGovernor_;\n    }\n\n    function pullGovernor() public virtual override {\n        require(msg.sender == _newGovernor, \"Governable: must be new governor to pull\");\n        emit GovernorPulled(_governor, _newGovernor);\n        _governor = _newGovernor;\n        _newGovernor = address(0);\n    }\n}\n"
    },
    "contracts/types/NoteKeeper.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport \"../types/FrontEndRewarder.sol\";\n\nimport \"../interfaces/IgOHM.sol\";\nimport \"../interfaces/IStaking.sol\";\nimport \"../interfaces/ITreasury.sol\";\nimport \"../interfaces/INoteKeeper.sol\";\n\nabstract contract NoteKeeper is INoteKeeper, FrontEndRewarder {\n    mapping(address => Note[]) public notes; // user deposit data\n    mapping(address => mapping(uint256 => address)) private noteTransfers; // change note ownership\n\n    IgOHM internal immutable gOHM;\n    IStaking internal immutable staking;\n    ITreasury internal treasury;\n\n    constructor(\n        IOlympusAuthority _authority,\n        IERC20 _ohm,\n        IgOHM _gohm,\n        IStaking _staking,\n        ITreasury _treasury\n    ) FrontEndRewarder(_authority, _ohm) {\n        gOHM = _gohm;\n        staking = _staking;\n        treasury = _treasury;\n    }\n\n    // if treasury address changes on authority, update it\n    function updateTreasury() external {\n        require(\n            msg.sender == authority.governor() ||\n                msg.sender == authority.guardian() ||\n                msg.sender == authority.policy(),\n            \"Only authorized\"\n        );\n        treasury = ITreasury(authority.vault());\n    }\n\n    /* ========== ADD ========== */\n\n    /**\n     * @notice             adds a new Note for a user, stores the front end & DAO rewards, and mints & stakes payout & rewards\n     * @param _user        the user that owns the Note\n     * @param _payout      the amount of OHM due to the user\n     * @param _expiry      the timestamp when the Note is redeemable\n     * @param _marketID    the ID of the market deposited into\n     * @return index_      the index of the Note in the user's array\n     */\n    function addNote(\n        address _user,\n        uint256 _payout,\n        uint48 _expiry,\n        uint48 _marketID,\n        address _referral\n    ) internal returns (uint256 index_) {\n        // the index of the note is the next in the user's array\n        index_ = notes[_user].length;\n\n        // the new note is pushed to the user's array\n        notes[_user].push(\n            Note({\n                payout: gOHM.balanceTo(_payout),\n                created: uint48(block.timestamp),\n                matured: _expiry,\n                redeemed: 0,\n                marketID: _marketID\n            })\n        );\n\n        // front end operators can earn rewards by referring users\n        uint256 rewards = _giveRewards(_payout, _referral);\n\n        // mint and stake payout\n        treasury.mint(address(this), _payout + rewards);\n\n        // note that only the payout gets staked (front end rewards are in OHM)\n        staking.stake(address(this), _payout, false, true);\n    }\n\n    /* ========== REDEEM ========== */\n\n    /**\n     * @notice             redeem notes for user\n     * @param _user        the user to redeem for\n     * @param _indexes     the note indexes to redeem\n     * @param _sendgOHM    send payout as gOHM or sOHM\n     * @return payout_     sum of payout sent, in gOHM\n     */\n    function redeem(\n        address _user,\n        uint256[] memory _indexes,\n        bool _sendgOHM\n    ) public override returns (uint256 payout_) {\n        uint48 time = uint48(block.timestamp);\n\n        for (uint256 i = 0; i < _indexes.length; i++) {\n            (uint256 pay, bool matured) = pendingFor(_user, _indexes[i]);\n\n            if (matured) {\n                notes[_user][_indexes[i]].redeemed = time; // mark as redeemed\n                payout_ += pay;\n            }\n        }\n\n        if (_sendgOHM) {\n            gOHM.transfer(_user, payout_); // send payout as gOHM\n        } else {\n            staking.unwrap(_user, payout_); // unwrap and send payout as sOHM\n        }\n    }\n\n    /**\n     * @notice             redeem all redeemable markets for user\n     * @dev                if possible, query indexesFor() off-chain and input in redeem() to save gas\n     * @param _user        user to redeem all notes for\n     * @param _sendgOHM    send payout as gOHM or sOHM\n     * @return             sum of payout sent, in gOHM\n     */\n    function redeemAll(address _user, bool _sendgOHM) external override returns (uint256) {\n        return redeem(_user, indexesFor(_user), _sendgOHM);\n    }\n\n    /* ========== TRANSFER ========== */\n\n    /**\n     * @notice             approve an address to transfer a note\n     * @param _to          address to approve note transfer for\n     * @param _index       index of note to approve transfer for\n     */\n    function pushNote(address _to, uint256 _index) external override {\n        require(notes[msg.sender][_index].created != 0, \"Depository: note not found\");\n        noteTransfers[msg.sender][_index] = _to;\n    }\n\n    /**\n     * @notice             transfer a note that has been approved by an address\n     * @param _from        the address that approved the note transfer\n     * @param _index       the index of the note to transfer (in the sender's array)\n     */\n    function pullNote(address _from, uint256 _index) external override returns (uint256 newIndex_) {\n        require(noteTransfers[_from][_index] == msg.sender, \"Depository: transfer not found\");\n        require(notes[_from][_index].redeemed == 0, \"Depository: note redeemed\");\n\n        newIndex_ = notes[msg.sender].length;\n        notes[msg.sender].push(notes[_from][_index]);\n\n        delete notes[_from][_index];\n    }\n\n    /* ========== VIEW ========== */\n\n    // Note info\n\n    /**\n     * @notice             all pending notes for user\n     * @param _user        the user to query notes for\n     * @return             the pending notes for the user\n     */\n    function indexesFor(address _user) public view override returns (uint256[] memory) {\n        Note[] memory info = notes[_user];\n\n        uint256 length;\n        for (uint256 i = 0; i < info.length; i++) {\n            if (info[i].redeemed == 0 && info[i].payout != 0) length++;\n        }\n\n        uint256[] memory indexes = new uint256[](length);\n        uint256 position;\n\n        for (uint256 i = 0; i < info.length; i++) {\n            if (info[i].redeemed == 0 && info[i].payout != 0) {\n                indexes[position] = i;\n                position++;\n            }\n        }\n\n        return indexes;\n    }\n\n    /**\n     * @notice             calculate amount available for claim for a single note\n     * @param _user        the user that the note belongs to\n     * @param _index       the index of the note in the user's array\n     * @return payout_     the payout due, in gOHM\n     * @return matured_    if the payout can be redeemed\n     */\n    function pendingFor(address _user, uint256 _index) public view override returns (uint256 payout_, bool matured_) {\n        Note memory note = notes[_user][_index];\n\n        payout_ = note.payout;\n        matured_ = note.redeemed == 0 && note.matured <= block.timestamp && note.payout != 0;\n    }\n}\n"
    },
    "contracts/types/OlympusAccessControlled.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.7.5;\n\nimport \"../interfaces/IOlympusAuthority.sol\";\n\nabstract contract OlympusAccessControlled {\n    /* ========== EVENTS ========== */\n\n    event AuthorityUpdated(IOlympusAuthority indexed authority);\n\n    string UNAUTHORIZED = \"UNAUTHORIZED\"; // save gas\n\n    /* ========== STATE VARIABLES ========== */\n\n    IOlympusAuthority public authority;\n\n    /* ========== Constructor ========== */\n\n    constructor(IOlympusAuthority _authority) {\n        authority = _authority;\n        emit AuthorityUpdated(_authority);\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyGovernor() {\n        require(msg.sender == authority.governor(), UNAUTHORIZED);\n        _;\n    }\n\n    modifier onlyGuardian() {\n        require(msg.sender == authority.guardian(), UNAUTHORIZED);\n        _;\n    }\n\n    modifier onlyPolicy() {\n        require(msg.sender == authority.policy(), UNAUTHORIZED);\n        _;\n    }\n\n    modifier onlyVault() {\n        require(msg.sender == authority.vault(), UNAUTHORIZED);\n        _;\n    }\n\n    /* ========== GOV ONLY ========== */\n\n    function setAuthority(IOlympusAuthority _newAuthority) external onlyGovernor {\n        authority = _newAuthority;\n        emit AuthorityUpdated(_newAuthority);\n    }\n}\n"
    },
    "contracts/types/OlympusAccessControlledV2.sol": {
      "content": "pragma solidity ^0.8.10;\n\nimport \"../interfaces/IOlympusAuthority.sol\";\n\nerror UNAUTHORIZED();\nerror AUTHORITY_INITIALIZED();\n\n/// @dev Reasoning for this contract = modifiers literaly copy code\n/// instead of pointing towards the logic to execute. Over many\n/// functions this bloats contract size unnecessarily.\n/// imho modifiers are a meme.\nabstract contract OlympusAccessControlledV2 {\n    /* ========== EVENTS ========== */\n\n    event AuthorityUpdated(IOlympusAuthority authority);\n\n    /* ========== STATE VARIABLES ========== */\n\n    IOlympusAuthority public authority;\n\n    /* ========== Constructor ========== */\n\n    constructor(IOlympusAuthority _authority) {\n        authority = _authority;\n        emit AuthorityUpdated(_authority);\n    }\n\n    /* ========== \"MODIFIERS\" ========== */\n\n    modifier onlyGovernor {\n\t_onlyGovernor();\n\t_;\n    }\n\n    modifier onlyGuardian {\n\t_onlyGuardian();\n\t_;\n    }\n\n    modifier onlyPolicy {\n\t_onlyPolicy();\n\t_;\n    }\n\n    modifier onlyVault {\n\t_onlyVault();\n\t_;\n    }\n\n    /* ========== GOV ONLY ========== */\n\n    function initializeAuthority(IOlympusAuthority _newAuthority) internal {\n        if (authority != IOlympusAuthority(address(0))) revert AUTHORITY_INITIALIZED();\n        authority = _newAuthority;\n        emit AuthorityUpdated(_newAuthority);\n    }\n\n    function setAuthority(IOlympusAuthority _newAuthority) external {\n        _onlyGovernor();\n        authority = _newAuthority;\n        emit AuthorityUpdated(_newAuthority);\n    }\n\n    /* ========== INTERNAL CHECKS ========== */\n\n    function _onlyGovernor() internal view {\n        if (msg.sender != authority.governor()) revert UNAUTHORIZED();\n    }\n\n    function _onlyGuardian() internal view {\n        if (msg.sender != authority.guardian()) revert UNAUTHORIZED();\n    }\n\n    function _onlyPolicy() internal view {\n        if (msg.sender != authority.policy()) revert UNAUTHORIZED();\n    }\n\n    function _onlyVault() internal view {\n        if (msg.sender != authority.vault()) revert UNAUTHORIZED();\n    }\n}\n"
    },
    "contracts/types/Ownable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.7.5;\n\nimport \"../interfaces/IOwnable.sol\";\n\nabstract contract Ownable is IOwnable {\n    address internal _owner;\n    address internal _newOwner;\n\n    event OwnershipPushed(address indexed previousOwner, address indexed newOwner);\n    event OwnershipPulled(address indexed previousOwner, address indexed newOwner);\n\n    constructor() {\n        _owner = msg.sender;\n        emit OwnershipPushed(address(0), _owner);\n    }\n\n    function owner() public view override returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceManagement() public virtual override onlyOwner {\n        emit OwnershipPulled(_owner, address(0));\n        _owner = address(0);\n        _newOwner = address(0);\n    }\n\n    function pushManagement(address newOwner_) public virtual override onlyOwner {\n        emit OwnershipPushed(_owner, newOwner_);\n        _newOwner = newOwner_;\n    }\n\n    function pullManagement() public virtual override {\n        require(msg.sender == _newOwner, \"Ownable: must be new owner to pull\");\n        emit OwnershipPulled(_owner, _newOwner);\n        _owner = _newOwner;\n        _newOwner = address(0);\n    }\n}\n"
    },
    "contracts/types/VaultOwned.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.7.5;\n\nimport \"./Ownable.sol\";\n\ncontract VaultOwned is Ownable {\n    address internal _vault;\n\n    function setVault(address vault_) external onlyOwner returns (bool) {\n        _vault = vault_;\n\n        return true;\n    }\n\n    function vault() public view returns (address) {\n        return _vault;\n    }\n\n    modifier onlyVault() {\n        require(_vault == msg.sender, \"VaultOwned: caller is not the Vault\");\n        _;\n    }\n}\n"
    },
    "contracts/types/YieldSplitter.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"../interfaces/IERC20.sol\";\nimport {IgOHM} from \"../interfaces/IgOHM.sol\";\nimport {SafeERC20} from \"../libraries/SafeERC20.sol\";\nimport {OlympusAccessControlledV2, IOlympusAuthority} from \"../types/OlympusAccessControlledV2.sol\";\n\n/**\n    @title IOHMIndexWrapper\n    @notice This interface is used to wrap cross-chain oracles to feed an index without needing IsOHM, \n    while also being able to use sOHM on mainnet.\n */\ninterface IOHMIndexWrapper {\n    function index() external view returns (uint256 index);\n}\n\n/**\n    @title IYieldSplitter\n    @notice This interface will be used to access common functions between yieldsplitter implementations.\n    This will allow certain operations to be done regardless of implementation details.\n */\n interface IYieldSplitter {\n\n    function redeemYieldOnBehalfOf(uint256 id_) external returns (uint256);\n\n    function redeemAllYieldOnBehalfOf(address recipient_) external returns (uint256);\n\n    function givePermissionToRedeem(address address_) external;\n\n    function revokePermissionToRedeem(address address_) external;\n\n    function redeemableBalance(uint256 depositId_) external view returns (uint256);\n\n    function totalRedeemableBalance(address recipient_) external view returns (uint256);\n\n    function getDepositorIds(address donor_) external view returns (uint256[] memory);\n}\n\nerror YieldSplitter_NotYourDeposit();\n\n/**\n    @title YieldSplitter\n    @notice Abstract contract that allows users to create deposits for their gOHM and have\n            their yield claimable by the specified recipient party. This contract's functions\n            are designed to be as generic as possible. This contract's responsibility is\n            the accounting of the yield splitting and some error handling. All other logic such as\n            emergency controls, sending and recieving gOHM is up to the implementation of\n            this abstract contract to handle.\n */\nabstract contract YieldSplitter is OlympusAccessControlledV2, IYieldSplitter {\n    using SafeERC20 for IERC20;\n\n    IOHMIndexWrapper public immutable indexWrapper;\n\n    struct DepositInfo {\n        uint256 id;\n        address depositor;\n        uint256 principalAmount; // Total amount of sOhm deposited as principal, 9 decimals.\n        uint256 agnosticAmount; // Total amount deposited priced in gOhm. 18 decimals.\n    }\n\n    uint256 public idCount;\n    mapping(uint256 => DepositInfo) public depositInfo; // depositId -> DepositInfo\n    mapping(address => uint256[]) public depositorIds; // address -> Array of the deposit id's deposited by user\n    mapping(address => bool) public hasPermissionToRedeem; // keep track of which contracts can redeem deposits on behalf of users\n\n    /**\n        @notice Constructor\n        @param indexWrapper_ Address of contract that will return the sOHM to gOHM index. \n                             On mainnet this will be sOHM but on other chains can be an oracle wrapper.\n    */\n    constructor(address indexWrapper_, address authority_) OlympusAccessControlledV2(IOlympusAuthority(authority_)) {\n        indexWrapper = IOHMIndexWrapper(indexWrapper_);\n    }\n\n    /**\n        @notice Create a deposit.\n        @param depositor_ Address of depositor\n        @param amount_ Amount in gOhm. 18 decimals.\n    */\n    function _deposit(address depositor_, uint256 amount_) internal returns (uint256 depositId) {\n        depositorIds[depositor_].push(idCount);\n\n        depositInfo[idCount] = DepositInfo({\n            id: idCount,\n            depositor: depositor_,\n            principalAmount: _fromAgnostic(amount_),\n            agnosticAmount: amount_\n        });\n\n        depositId = idCount;\n        idCount++;\n    }\n\n    /**\n        @notice Add more gOhm to the depositor's principal deposit.\n        @param id_ Id of the deposit.\n        @param amount_ Amount of gOhm to add. 18 decimals.\n    */\n    function _addToDeposit(\n        uint256 id_,\n        uint256 amount_,\n        address depositorAddress\n    ) internal {\n        if (depositInfo[id_].depositor != depositorAddress) revert YieldSplitter_NotYourDeposit();\n\n        DepositInfo storage userDeposit = depositInfo[id_];\n        userDeposit.principalAmount += _fromAgnostic(amount_);\n        userDeposit.agnosticAmount += amount_;\n    }\n\n    /**\n        @notice Withdraw part of the principal amount deposited.\n        @param id_ Id of the deposit.\n        @param amount_ Amount of gOHM to withdraw.\n    */\n    function _withdrawPrincipal(\n        uint256 id_,\n        uint256 amount_,\n        address depositorAddress\n    ) internal {\n        if (depositInfo[id_].depositor != depositorAddress) revert YieldSplitter_NotYourDeposit();\n\n        DepositInfo storage userDeposit = depositInfo[id_];\n        userDeposit.principalAmount -= _fromAgnostic(amount_); // Reverts if amount > principal due to underflow\n        userDeposit.agnosticAmount -= amount_;\n    }\n\n    /**\n        @notice Withdraw all of the principal amount deposited.\n        @param id_ Id of the deposit.\n        @return amountWithdrawn : amount of gOHM withdrawn. 18 decimals.\n    */\n    function _withdrawAllPrincipal(uint256 id_, address depositorAddress) internal returns (uint256 amountWithdrawn) {\n        if (depositInfo[id_].depositor != depositorAddress) revert YieldSplitter_NotYourDeposit();\n\n        DepositInfo storage userDeposit = depositInfo[id_];\n        amountWithdrawn = _toAgnostic(userDeposit.principalAmount);\n        userDeposit.principalAmount = 0;\n        userDeposit.agnosticAmount -= amountWithdrawn;\n    }\n\n    /**\n        @notice Redeem excess yield from your deposit in sOHM.\n        @param id_ Id of the deposit.\n        @return amountRedeemed : amount of yield redeemed in gOHM. 18 decimals.\n    */\n    function _redeemYield(uint256 id_) internal returns (uint256 amountRedeemed) {\n        DepositInfo storage userDeposit = depositInfo[id_];\n\n        amountRedeemed = _getOutstandingYield(userDeposit.principalAmount, userDeposit.agnosticAmount);\n        userDeposit.agnosticAmount = userDeposit.agnosticAmount - amountRedeemed;\n    }\n\n    /**\n        @notice Close a deposit. Remove all information in both the deposit info, depositorIds and recipientIds.\n        @param id_ Id of the deposit.\n        @dev Internally for accounting reasons principal amount is stored in 9 decimal OHM terms. \n        Since most implementations will work will gOHM, principal here is returned externally in 18 decimal gOHM terms.\n        @return principal : amount of principal that was deleted. in gOHM. 18 decimals.\n        @return agnosticAmount : total amount of gOHM deleted. Principal + Yield. 18 decimals.\n    */\n    function _closeDeposit(uint256 id_, address depositorAddress)\n        internal\n        returns (uint256 principal, uint256 agnosticAmount)\n    {\n        address depositorAddressToClose = depositInfo[id_].depositor;\n        if (depositorAddressToClose != depositorAddress) revert YieldSplitter_NotYourDeposit();\n\n        principal = _toAgnostic(depositInfo[id_].principalAmount);\n        agnosticAmount = depositInfo[id_].agnosticAmount;\n\n        uint256[] storage depositorIdsArray = depositorIds[depositorAddressToClose];\n        for (uint256 i = 0; i < depositorIdsArray.length; i++) {\n            if (depositorIdsArray[i] == id_) {\n                // Remove id from depositor's ids array\n                depositorIdsArray[i] = depositorIdsArray[depositorIdsArray.length - 1]; // Delete integer from array by swapping with last element and calling pop()\n                depositorIdsArray.pop();\n                break;\n            }\n        }\n\n        delete depositInfo[id_];\n    }\n\n    /**\n        @notice Redeems yield from a deposit and sends it to the recipient\n        @param id_ Id of the deposit.\n    */\n    function redeemYieldOnBehalfOf(uint256 id_) external virtual returns (uint256) {}\n\n    /**\n        @notice Redeems all yield tied to a recipient and sends it to the recipient\n        @param recipient_ recipient address.\n    */\n    function redeemAllYieldOnBehalfOf(address recipient_) external virtual returns (uint256) {}\n\n    /**\n        @notice Get redeemable gOHM balance of a specific deposit\n        @param depositId_ Deposit ID for this donation\n    */\n    function redeemableBalance(uint256 depositId_) public view virtual returns (uint256) {}\n\n    /**\n        @notice Get redeemable gOHM balance of a recipient address\n        @param recipient_ Address of user receiving donated yield\n     */\n    function totalRedeemableBalance(address recipient_) external view virtual returns (uint256) {}\n\n    /**\n        @notice Gives a contract permission to redeem yield on behalf of users\n        @param address_ Id of the deposit.\n    */\n    function givePermissionToRedeem(address address_) external {\n        _onlyGuardian();\n        hasPermissionToRedeem[address_] = true;\n    }\n\n    /**\n        @notice Revokes a contract permission to redeem yield on behalf of users\n        @param address_ Id of the deposit.\n    */\n    function revokePermissionToRedeem(address address_) external {\n        _onlyGuardian();\n        hasPermissionToRedeem[address_] = false;\n    }\n\n    /**\n        @notice Returns the array of deposit id's belonging to the depositor\n        @return uint256[] array of depositor Id's\n     */\n    function getDepositorIds(address donor_) external view returns (uint256[] memory) {\n        return depositorIds[donor_];\n    }\n\n    /**\n        @notice Calculate outstanding yield redeemable based on principal and agnosticAmount.\n        @return uint256 amount of yield in gOHM. 18 decimals.\n     */\n    function _getOutstandingYield(uint256 principal_, uint256 agnosticAmount_) internal view returns (uint256) {\n        // agnosticAmount must be greater than or equal to _toAgnostic(principal_) since agnosticAmount_\n        // is the sum of principal_ and the yield. Thus this can be unchecked.\n        unchecked { return agnosticAmount_ - _toAgnostic(principal_); }\n    }\n\n    /**\n        @notice Convert flat sOHM value to agnostic gOHM value at current index\n        @dev Agnostic value earns rebases. Agnostic value is amount / rebase_index.\n             1e18 is because sOHM has 9 decimals, gOHM has 18 and index has 9.\n     */\n    function _toAgnostic(uint256 amount_) internal view returns (uint256) {\n        return (amount_ * 1e18) / (indexWrapper.index());\n    }\n\n    /**\n        @notice Convert agnostic gOHM value at current index to flat sOHM value\n        @dev Agnostic value earns rebases. sOHM amount is gOHMamount * rebase_index.\n             1e18 is because sOHM has 9 decimals, gOHM has 18 and index has 9.\n     */\n    function _fromAgnostic(uint256 amount_) internal view returns (uint256) {\n        return (amount_ * (indexWrapper.index())) / 1e18;\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n\t}\n\n\tfunction logUint(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}